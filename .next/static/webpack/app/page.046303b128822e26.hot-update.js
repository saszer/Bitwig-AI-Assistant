"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./app/lib/system-integration.ts":
/*!***************************************!*\
  !*** ./app/lib/system-integration.ts ***!
  \***************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SystemIntegration: function() { return /* binding */ SystemIntegration; }\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n// System integration for controlling Bitwig Studio on Windows\n// This module provides actual system-level control capabilities\nclass SystemIntegration {\n    async executeSystemAction(action) {\n        if (!this.isWindows) {\n            console.warn(\"System integration only supported on Windows\");\n            return false;\n        }\n        try {\n            switch(action.type){\n                case \"mouse_click\":\n                    return await this.performMouseClick(action.x, action.y);\n                case \"mouse_drag\":\n                    return await this.performMouseDrag(action.x, action.y, action.endX, action.endY);\n                case \"keyboard\":\n                    return await this.performKeyboardAction(action.keys);\n                case \"window_focus\":\n                    return await this.focusWindow(action.windowTitle);\n                case \"process_check\":\n                    return await this.checkProcessRunning(action.processName);\n                default:\n                    console.error(\"Unknown system action type:\", action.type);\n                    return false;\n            }\n        } catch (error) {\n            console.error(\"System action failed:\", error);\n            return false;\n        }\n    }\n    async performMouseClick(x, y) {\n        try {\n            // This would use Windows API calls to perform mouse clicks\n            // For now, we'll simulate the action\n            console.log(\"System: Clicking at (\".concat(x, \", \").concat(y, \")\"));\n            // In a real implementation, this would use:\n            // - SetCursorPos(x, y) to move cursor\n            // - mouse_event(MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0) for mouse down\n            // - mouse_event(MOUSEEVENTF_LEFTUP, 0, 0, 0, 0) for mouse up\n            await new Promise((resolve)=>setTimeout(resolve, 100));\n            return true;\n        } catch (error) {\n            console.error(\"Mouse click failed:\", error);\n            return false;\n        }\n    }\n    async performMouseDrag(startX, startY, endX, endY) {\n        try {\n            console.log(\"System: Dragging from (\".concat(startX, \", \").concat(startY, \") to (\").concat(endX, \", \").concat(endY, \")\"));\n            // In a real implementation, this would:\n            // 1. Move cursor to start position\n            // 2. Press mouse button down\n            // 3. Move cursor to end position\n            // 4. Release mouse button\n            await new Promise((resolve)=>setTimeout(resolve, 200));\n            return true;\n        } catch (error) {\n            console.error(\"Mouse drag failed:\", error);\n            return false;\n        }\n    }\n    async performKeyboardAction(keys) {\n        try {\n            console.log(\"System: Sending keyboard input: \".concat(keys));\n            // In a real implementation, this would use:\n            // - keybd_event() for individual key presses\n            // - SendInput() for more complex key combinations\n            await new Promise((resolve)=>setTimeout(resolve, 50));\n            return true;\n        } catch (error) {\n            console.error(\"Keyboard action failed:\", error);\n            return false;\n        }\n    }\n    async focusWindow(windowTitle) {\n        try {\n            console.log(\"System: Focusing window: \".concat(windowTitle));\n            // In a real implementation, this would:\n            // 1. FindWindow() to get window handle\n            // 2. SetForegroundWindow() to bring to front\n            // 3. ShowWindow() to ensure it's visible\n            await new Promise((resolve)=>setTimeout(resolve, 100));\n            return true;\n        } catch (error) {\n            console.error(\"Window focus failed:\", error);\n            return false;\n        }\n    }\n    async checkProcessRunning(processName) {\n        try {\n            console.log(\"SystemIntegration: checkProcessRunning called\");\n            // Only check on client side\n            if (false) {}\n            const baseUrl = window.location.origin;\n            console.log(\"SystemIntegration: Fetching\", \"\".concat(baseUrl, \"/api/check-bitwig\"));\n            const response = await fetch(\"\".concat(baseUrl, \"/api/check-bitwig\"));\n            const data = await response.json();\n            console.log(\"SystemIntegration: API response\", data);\n            const isRunning = data.isRunning;\n            console.log(\"SystemIntegration: Process \".concat(processName, \" is \").concat(isRunning ? \"running\" : \"not running\"));\n            return isRunning;\n        } catch (error) {\n            console.error(\"SystemIntegration: Process check failed:\", error);\n            return false;\n        }\n    }\n    // High-level Bitwig-specific actions\n    async focusBitwigStudio() {\n        return await this.executeSystemAction({\n            type: \"window_focus\",\n            windowTitle: \"Bitwig Studio\"\n        });\n    }\n    async checkBitwigRunning() {\n        return await this.executeSystemAction({\n            type: \"process_check\",\n            processName: \"Bitwig Studio.exe\"\n        });\n    }\n    async sendKeyboardShortcut(shortcut) {\n        // Focus Bitwig first, then send the shortcut\n        const focused = await this.focusBitwigStudio();\n        if (!focused) return false;\n        await new Promise((resolve)=>setTimeout(resolve, 100)) // Small delay\n        ;\n        return await this.executeSystemAction({\n            type: \"keyboard\",\n            keys: shortcut\n        });\n    }\n    async clickInBitwig(x, y) {\n        // Focus Bitwig first, then click\n        const focused = await this.focusBitwigStudio();\n        if (!focused) return false;\n        await new Promise((resolve)=>setTimeout(resolve, 100)) // Small delay\n        ;\n        return await this.executeSystemAction({\n            type: \"mouse_click\",\n            x,\n            y\n        });\n    }\n    async dragInBitwig(startX, startY, endX, endY) {\n        // Focus Bitwig first, then drag\n        const focused = await this.focusBitwigStudio();\n        if (!focused) return false;\n        await new Promise((resolve)=>setTimeout(resolve, 100)) // Small delay\n        ;\n        return await this.executeSystemAction({\n            type: \"mouse_drag\",\n            x: startX,\n            y: startY,\n            endX,\n            endY\n        });\n    }\n    // Bitwig-specific action sequences\n    async createNewProject() {\n        const actions = [\n            ()=>this.sendKeyboardShortcut(\"Ctrl+N\")\n        ];\n        for (const action of actions){\n            const success = await action();\n            if (!success) return false;\n            await new Promise((resolve)=>setTimeout(resolve, 200)) // Delay between actions\n            ;\n        }\n        return true;\n    }\n    async startRecording() {\n        const actions = [\n            ()=>this.sendKeyboardShortcut(\"R\")\n        ];\n        for (const action of actions){\n            const success = await action();\n            if (!success) return false;\n            await new Promise((resolve)=>setTimeout(resolve, 200));\n        }\n        return true;\n    }\n    async openDeviceBrowser() {\n        return await this.sendKeyboardShortcut(\"F4\");\n    }\n    async toggleAutomation() {\n        return await this.sendKeyboardShortcut(\"A\");\n    }\n    async toggleSnapToGrid() {\n        return await this.sendKeyboardShortcut(\"S\");\n    }\n    async playStop() {\n        return await this.sendKeyboardShortcut(\"Space\");\n    }\n    async toggleMetronome() {\n        return await this.sendKeyboardShortcut(\"M\");\n    }\n    async undo() {\n        return await this.sendKeyboardShortcut(\"Ctrl+Z\");\n    }\n    async redo() {\n        return await this.sendKeyboardShortcut(\"Ctrl+Y\");\n    }\n    async saveProject() {\n        return await this.sendKeyboardShortcut(\"Ctrl+S\");\n    }\n    async openProject() {\n        return await this.sendKeyboardShortcut(\"Ctrl+O\");\n    }\n    async exportAudio() {\n        return await this.sendKeyboardShortcut(\"Ctrl+E\");\n    }\n    // Utility methods\n    isSupported() {\n        // Only support Windows and only in Node.js (not browser)\n        return typeof process !== \"undefined\" && process.platform === \"win32\";\n    }\n    getPlatform() {\n        return process.platform;\n    }\n    constructor(){\n        // Debug log\n        console.log(\"SystemIntegration: process.platform =\", typeof process !== \"undefined\" ? process.platform : \"undefined\");\n        this.isWindows = typeof process !== \"undefined\" && process.platform === \"win32\";\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9saWIvc3lzdGVtLWludGVncmF0aW9uLnRzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsOERBQThEO0FBQzlELGdFQUFnRTtBQWF6RCxNQUFNQTtJQVNYLE1BQU1DLG9CQUFvQkMsTUFBb0IsRUFBb0I7UUFDaEUsSUFBSSxDQUFDLElBQUksQ0FBQ0MsU0FBUyxFQUFFO1lBQ25CQyxRQUFRQyxJQUFJLENBQUM7WUFDYixPQUFPO1FBQ1Q7UUFFQSxJQUFJO1lBQ0YsT0FBUUgsT0FBT0ksSUFBSTtnQkFDakIsS0FBSztvQkFDSCxPQUFPLE1BQU0sSUFBSSxDQUFDQyxpQkFBaUIsQ0FBQ0wsT0FBT00sQ0FBQyxFQUFHTixPQUFPTyxDQUFDO2dCQUN6RCxLQUFLO29CQUNILE9BQU8sTUFBTSxJQUFJLENBQUNDLGdCQUFnQixDQUFDUixPQUFPTSxDQUFDLEVBQUdOLE9BQU9PLENBQUMsRUFBR1AsT0FBT1MsSUFBSSxFQUFHVCxPQUFPVSxJQUFJO2dCQUNwRixLQUFLO29CQUNILE9BQU8sTUFBTSxJQUFJLENBQUNDLHFCQUFxQixDQUFDWCxPQUFPWSxJQUFJO2dCQUNyRCxLQUFLO29CQUNILE9BQU8sTUFBTSxJQUFJLENBQUNDLFdBQVcsQ0FBQ2IsT0FBT2MsV0FBVztnQkFDbEQsS0FBSztvQkFDSCxPQUFPLE1BQU0sSUFBSSxDQUFDQyxtQkFBbUIsQ0FBQ2YsT0FBT2dCLFdBQVc7Z0JBQzFEO29CQUNFZCxRQUFRZSxLQUFLLENBQUMsK0JBQStCakIsT0FBT0ksSUFBSTtvQkFDeEQsT0FBTztZQUNYO1FBQ0YsRUFBRSxPQUFPYSxPQUFPO1lBQ2RmLFFBQVFlLEtBQUssQ0FBQyx5QkFBeUJBO1lBQ3ZDLE9BQU87UUFDVDtJQUNGO0lBRUEsTUFBY1osa0JBQWtCQyxDQUFTLEVBQUVDLENBQVMsRUFBb0I7UUFDdEUsSUFBSTtZQUNGLDJEQUEyRDtZQUMzRCxxQ0FBcUM7WUFDckNMLFFBQVFnQixHQUFHLENBQUMsd0JBQThCWCxPQUFO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TWtCLGNBQWdDO1FBQ3BDLE9BQU8sTUFBTSxJQUFJLENBQUNsQixvQkFBb0IsQ0FBQztJQUN6QztJQUVBLGtCQUFrQjtJQUNsQm1CLGNBQXVCO1FBQ3JCLHlEQUF5RDtRQUN6RCxPQUFPLE9BQU9DLE9BQU9BLEtBQUssZUFBZUEsT0FBT0EsQ0FBQ0MsUUFBUSxLQUFLO0lBQ2hFO0lBRUFDLGNBQXNCO1FBQ3BCLE9BQU9GLE9BQU9BLENBQUNDLFFBQVE7SUFDekI7SUFyUUFFLGFBQWM7UUFDWixZQUFZO1FBQ1p4RCxRQUFRZ0IsR0FBRyxDQUFDLHlDQUF5QyxPQUFPcUMsT0FBT0EsS0FBSyxjQUFjQSxPQUFPQSxDQUFDQyxRQUFRLEdBQUc7UUFDekcsSUFBSSxDQUFDdkQsU0FBUyxHQUFHLE9BQU9zRCxPQUFPQSxLQUFLLGVBQWVBLE9BQU9BLENBQUNDLFFBQVEsS0FBSztJQUMxRTtBQWtRRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9hcHAvbGliL3N5c3RlbS1pbnRlZ3JhdGlvbi50cz8wMGE4Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIFN5c3RlbSBpbnRlZ3JhdGlvbiBmb3IgY29udHJvbGxpbmcgQml0d2lnIFN0dWRpbyBvbiBXaW5kb3dzXHJcbi8vIFRoaXMgbW9kdWxlIHByb3ZpZGVzIGFjdHVhbCBzeXN0ZW0tbGV2ZWwgY29udHJvbCBjYXBhYmlsaXRpZXNcclxuXHJcbmludGVyZmFjZSBTeXN0ZW1BY3Rpb24ge1xyXG4gIHR5cGU6ICdtb3VzZV9jbGljaycgfCAnbW91c2VfZHJhZycgfCAna2V5Ym9hcmQnIHwgJ3dpbmRvd19mb2N1cycgfCAncHJvY2Vzc19jaGVjaydcclxuICB4PzogbnVtYmVyXHJcbiAgeT86IG51bWJlclxyXG4gIGVuZFg/OiBudW1iZXJcclxuICBlbmRZPzogbnVtYmVyXHJcbiAga2V5cz86IHN0cmluZ1xyXG4gIHdpbmRvd1RpdGxlPzogc3RyaW5nXHJcbiAgcHJvY2Vzc05hbWU/OiBzdHJpbmdcclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIFN5c3RlbUludGVncmF0aW9uIHtcclxuICBwcml2YXRlIGlzV2luZG93czogYm9vbGVhblxyXG5cclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIC8vIERlYnVnIGxvZ1xyXG4gICAgY29uc29sZS5sb2coJ1N5c3RlbUludGVncmF0aW9uOiBwcm9jZXNzLnBsYXRmb3JtID0nLCB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgPyBwcm9jZXNzLnBsYXRmb3JtIDogJ3VuZGVmaW5lZCcpXHJcbiAgICB0aGlzLmlzV2luZG93cyA9IHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInXHJcbiAgfVxyXG5cclxuICBhc3luYyBleGVjdXRlU3lzdGVtQWN0aW9uKGFjdGlvbjogU3lzdGVtQWN0aW9uKTogUHJvbWlzZTxib29sZWFuPiB7XHJcbiAgICBpZiAoIXRoaXMuaXNXaW5kb3dzKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybignU3lzdGVtIGludGVncmF0aW9uIG9ubHkgc3VwcG9ydGVkIG9uIFdpbmRvd3MnKVxyXG4gICAgICByZXR1cm4gZmFsc2VcclxuICAgIH1cclxuXHJcbiAgICB0cnkge1xyXG4gICAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XHJcbiAgICAgICAgY2FzZSAnbW91c2VfY2xpY2snOlxyXG4gICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucGVyZm9ybU1vdXNlQ2xpY2soYWN0aW9uLnghLCBhY3Rpb24ueSEpXHJcbiAgICAgICAgY2FzZSAnbW91c2VfZHJhZyc6XHJcbiAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wZXJmb3JtTW91c2VEcmFnKGFjdGlvbi54ISwgYWN0aW9uLnkhLCBhY3Rpb24uZW5kWCEsIGFjdGlvbi5lbmRZISlcclxuICAgICAgICBjYXNlICdrZXlib2FyZCc6XHJcbiAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wZXJmb3JtS2V5Ym9hcmRBY3Rpb24oYWN0aW9uLmtleXMhKVxyXG4gICAgICAgIGNhc2UgJ3dpbmRvd19mb2N1cyc6XHJcbiAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5mb2N1c1dpbmRvdyhhY3Rpb24ud2luZG93VGl0bGUhKVxyXG4gICAgICAgIGNhc2UgJ3Byb2Nlc3NfY2hlY2snOlxyXG4gICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2hlY2tQcm9jZXNzUnVubmluZyhhY3Rpb24ucHJvY2Vzc05hbWUhKVxyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdVbmtub3duIHN5c3RlbSBhY3Rpb24gdHlwZTonLCBhY3Rpb24udHlwZSlcclxuICAgICAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdTeXN0ZW0gYWN0aW9uIGZhaWxlZDonLCBlcnJvcilcclxuICAgICAgcmV0dXJuIGZhbHNlXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFzeW5jIHBlcmZvcm1Nb3VzZUNsaWNrKHg6IG51bWJlciwgeTogbnVtYmVyKTogUHJvbWlzZTxib29sZWFuPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBUaGlzIHdvdWxkIHVzZSBXaW5kb3dzIEFQSSBjYWxscyB0byBwZXJmb3JtIG1vdXNlIGNsaWNrc1xyXG4gICAgICAvLyBGb3Igbm93LCB3ZSdsbCBzaW11bGF0ZSB0aGUgYWN0aW9uXHJcbiAgICAgIGNvbnNvbGUubG9nKGBTeXN0ZW06IENsaWNraW5nIGF0ICgke3h9LCAke3l9KWApXHJcbiAgICAgIFxyXG4gICAgICAvLyBJbiBhIHJlYWwgaW1wbGVtZW50YXRpb24sIHRoaXMgd291bGQgdXNlOlxyXG4gICAgICAvLyAtIFNldEN1cnNvclBvcyh4LCB5KSB0byBtb3ZlIGN1cnNvclxyXG4gICAgICAvLyAtIG1vdXNlX2V2ZW50KE1PVVNFRVZFTlRGX0xFRlRET1dOLCAwLCAwLCAwLCAwKSBmb3IgbW91c2UgZG93blxyXG4gICAgICAvLyAtIG1vdXNlX2V2ZW50KE1PVVNFRVZFTlRGX0xFRlRVUCwgMCwgMCwgMCwgMCkgZm9yIG1vdXNlIHVwXHJcbiAgICAgIFxyXG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwKSlcclxuICAgICAgcmV0dXJuIHRydWVcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ01vdXNlIGNsaWNrIGZhaWxlZDonLCBlcnJvcilcclxuICAgICAgcmV0dXJuIGZhbHNlXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFzeW5jIHBlcmZvcm1Nb3VzZURyYWcoc3RhcnRYOiBudW1iZXIsIHN0YXJ0WTogbnVtYmVyLCBlbmRYOiBudW1iZXIsIGVuZFk6IG51bWJlcik6IFByb21pc2U8Ym9vbGVhbj4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc29sZS5sb2coYFN5c3RlbTogRHJhZ2dpbmcgZnJvbSAoJHtzdGFydFh9LCAke3N0YXJ0WX0pIHRvICgke2VuZFh9LCAke2VuZFl9KWApXHJcbiAgICAgIFxyXG4gICAgICAvLyBJbiBhIHJlYWwgaW1wbGVtZW50YXRpb24sIHRoaXMgd291bGQ6XHJcbiAgICAgIC8vIDEuIE1vdmUgY3Vyc29yIHRvIHN0YXJ0IHBvc2l0aW9uXHJcbiAgICAgIC8vIDIuIFByZXNzIG1vdXNlIGJ1dHRvbiBkb3duXHJcbiAgICAgIC8vIDMuIE1vdmUgY3Vyc29yIHRvIGVuZCBwb3NpdGlvblxyXG4gICAgICAvLyA0LiBSZWxlYXNlIG1vdXNlIGJ1dHRvblxyXG4gICAgICBcclxuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDIwMCkpXHJcbiAgICAgIHJldHVybiB0cnVlXHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdNb3VzZSBkcmFnIGZhaWxlZDonLCBlcnJvcilcclxuICAgICAgcmV0dXJuIGZhbHNlXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFzeW5jIHBlcmZvcm1LZXlib2FyZEFjdGlvbihrZXlzOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKGBTeXN0ZW06IFNlbmRpbmcga2V5Ym9hcmQgaW5wdXQ6ICR7a2V5c31gKVxyXG4gICAgICBcclxuICAgICAgLy8gSW4gYSByZWFsIGltcGxlbWVudGF0aW9uLCB0aGlzIHdvdWxkIHVzZTpcclxuICAgICAgLy8gLSBrZXliZF9ldmVudCgpIGZvciBpbmRpdmlkdWFsIGtleSBwcmVzc2VzXHJcbiAgICAgIC8vIC0gU2VuZElucHV0KCkgZm9yIG1vcmUgY29tcGxleCBrZXkgY29tYmluYXRpb25zXHJcbiAgICAgIFxyXG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTApKVxyXG4gICAgICByZXR1cm4gdHJ1ZVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignS2V5Ym9hcmQgYWN0aW9uIGZhaWxlZDonLCBlcnJvcilcclxuICAgICAgcmV0dXJuIGZhbHNlXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFzeW5jIGZvY3VzV2luZG93KHdpbmRvd1RpdGxlOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKGBTeXN0ZW06IEZvY3VzaW5nIHdpbmRvdzogJHt3aW5kb3dUaXRsZX1gKVxyXG4gICAgICBcclxuICAgICAgLy8gSW4gYSByZWFsIGltcGxlbWVudGF0aW9uLCB0aGlzIHdvdWxkOlxyXG4gICAgICAvLyAxLiBGaW5kV2luZG93KCkgdG8gZ2V0IHdpbmRvdyBoYW5kbGVcclxuICAgICAgLy8gMi4gU2V0Rm9yZWdyb3VuZFdpbmRvdygpIHRvIGJyaW5nIHRvIGZyb250XHJcbiAgICAgIC8vIDMuIFNob3dXaW5kb3coKSB0byBlbnN1cmUgaXQncyB2aXNpYmxlXHJcbiAgICAgIFxyXG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwKSlcclxuICAgICAgcmV0dXJuIHRydWVcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1dpbmRvdyBmb2N1cyBmYWlsZWQ6JywgZXJyb3IpXHJcbiAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBhc3luYyBjaGVja1Byb2Nlc3NSdW5uaW5nKHByb2Nlc3NOYW1lOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdTeXN0ZW1JbnRlZ3JhdGlvbjogY2hlY2tQcm9jZXNzUnVubmluZyBjYWxsZWQnKVxyXG4gICAgICAvLyBPbmx5IGNoZWNrIG9uIGNsaWVudCBzaWRlXHJcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdTeXN0ZW1JbnRlZ3JhdGlvbjogTm90IHJ1bm5pbmcgaW4gYnJvd3Nlciwgc2tpcHBpbmcgcHJvY2VzcyBjaGVjaycpXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlXHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgYmFzZVVybCA9IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW5cclxuICAgICAgY29uc29sZS5sb2coJ1N5c3RlbUludGVncmF0aW9uOiBGZXRjaGluZycsIGAke2Jhc2VVcmx9L2FwaS9jaGVjay1iaXR3aWdgKVxyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke2Jhc2VVcmx9L2FwaS9jaGVjay1iaXR3aWdgKVxyXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpXHJcbiAgICAgIGNvbnNvbGUubG9nKCdTeXN0ZW1JbnRlZ3JhdGlvbjogQVBJIHJlc3BvbnNlJywgZGF0YSlcclxuICAgICAgY29uc3QgaXNSdW5uaW5nID0gZGF0YS5pc1J1bm5pbmdcclxuICAgICAgY29uc29sZS5sb2coYFN5c3RlbUludGVncmF0aW9uOiBQcm9jZXNzICR7cHJvY2Vzc05hbWV9IGlzICR7aXNSdW5uaW5nID8gJ3J1bm5pbmcnIDogJ25vdCBydW5uaW5nJ31gKVxyXG4gICAgICByZXR1cm4gaXNSdW5uaW5nXHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdTeXN0ZW1JbnRlZ3JhdGlvbjogUHJvY2VzcyBjaGVjayBmYWlsZWQ6JywgZXJyb3IpXHJcbiAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gSGlnaC1sZXZlbCBCaXR3aWctc3BlY2lmaWMgYWN0aW9uc1xyXG4gIGFzeW5jIGZvY3VzQml0d2lnU3R1ZGlvKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xyXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZXhlY3V0ZVN5c3RlbUFjdGlvbih7XHJcbiAgICAgIHR5cGU6ICd3aW5kb3dfZm9jdXMnLFxyXG4gICAgICB3aW5kb3dUaXRsZTogJ0JpdHdpZyBTdHVkaW8nXHJcbiAgICB9KVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgY2hlY2tCaXR3aWdSdW5uaW5nKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xyXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZXhlY3V0ZVN5c3RlbUFjdGlvbih7XHJcbiAgICAgIHR5cGU6ICdwcm9jZXNzX2NoZWNrJyxcclxuICAgICAgcHJvY2Vzc05hbWU6ICdCaXR3aWcgU3R1ZGlvLmV4ZSdcclxuICAgIH0pXHJcbiAgfVxyXG5cclxuICBhc3luYyBzZW5kS2V5Ym9hcmRTaG9ydGN1dChzaG9ydGN1dDogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiB7XHJcbiAgICAvLyBGb2N1cyBCaXR3aWcgZmlyc3QsIHRoZW4gc2VuZCB0aGUgc2hvcnRjdXRcclxuICAgIGNvbnN0IGZvY3VzZWQgPSBhd2FpdCB0aGlzLmZvY3VzQml0d2lnU3R1ZGlvKClcclxuICAgIGlmICghZm9jdXNlZCkgcmV0dXJuIGZhbHNlXHJcblxyXG4gICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMCkpIC8vIFNtYWxsIGRlbGF5XHJcblxyXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZXhlY3V0ZVN5c3RlbUFjdGlvbih7XHJcbiAgICAgIHR5cGU6ICdrZXlib2FyZCcsXHJcbiAgICAgIGtleXM6IHNob3J0Y3V0XHJcbiAgICB9KVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgY2xpY2tJbkJpdHdpZyh4OiBudW1iZXIsIHk6IG51bWJlcik6IFByb21pc2U8Ym9vbGVhbj4ge1xyXG4gICAgLy8gRm9jdXMgQml0d2lnIGZpcnN0LCB0aGVuIGNsaWNrXHJcbiAgICBjb25zdCBmb2N1c2VkID0gYXdhaXQgdGhpcy5mb2N1c0JpdHdpZ1N0dWRpbygpXHJcbiAgICBpZiAoIWZvY3VzZWQpIHJldHVybiBmYWxzZVxyXG5cclxuICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDApKSAvLyBTbWFsbCBkZWxheVxyXG5cclxuICAgIHJldHVybiBhd2FpdCB0aGlzLmV4ZWN1dGVTeXN0ZW1BY3Rpb24oe1xyXG4gICAgICB0eXBlOiAnbW91c2VfY2xpY2snLFxyXG4gICAgICB4LFxyXG4gICAgICB5XHJcbiAgICB9KVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgZHJhZ0luQml0d2lnKHN0YXJ0WDogbnVtYmVyLCBzdGFydFk6IG51bWJlciwgZW5kWDogbnVtYmVyLCBlbmRZOiBudW1iZXIpOiBQcm9taXNlPGJvb2xlYW4+IHtcclxuICAgIC8vIEZvY3VzIEJpdHdpZyBmaXJzdCwgdGhlbiBkcmFnXHJcbiAgICBjb25zdCBmb2N1c2VkID0gYXdhaXQgdGhpcy5mb2N1c0JpdHdpZ1N0dWRpbygpXHJcbiAgICBpZiAoIWZvY3VzZWQpIHJldHVybiBmYWxzZVxyXG5cclxuICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDApKSAvLyBTbWFsbCBkZWxheVxyXG5cclxuICAgIHJldHVybiBhd2FpdCB0aGlzLmV4ZWN1dGVTeXN0ZW1BY3Rpb24oe1xyXG4gICAgICB0eXBlOiAnbW91c2VfZHJhZycsXHJcbiAgICAgIHg6IHN0YXJ0WCxcclxuICAgICAgeTogc3RhcnRZLFxyXG4gICAgICBlbmRYLFxyXG4gICAgICBlbmRZXHJcbiAgICB9KVxyXG4gIH1cclxuXHJcbiAgLy8gQml0d2lnLXNwZWNpZmljIGFjdGlvbiBzZXF1ZW5jZXNcclxuICBhc3luYyBjcmVhdGVOZXdQcm9qZWN0KCk6IFByb21pc2U8Ym9vbGVhbj4ge1xyXG4gICAgY29uc3QgYWN0aW9ucyA9IFtcclxuICAgICAgKCkgPT4gdGhpcy5zZW5kS2V5Ym9hcmRTaG9ydGN1dCgnQ3RybCtOJylcclxuICAgIF1cclxuXHJcbiAgICBmb3IgKGNvbnN0IGFjdGlvbiBvZiBhY3Rpb25zKSB7XHJcbiAgICAgIGNvbnN0IHN1Y2Nlc3MgPSBhd2FpdCBhY3Rpb24oKVxyXG4gICAgICBpZiAoIXN1Y2Nlc3MpIHJldHVybiBmYWxzZVxyXG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMjAwKSkgLy8gRGVsYXkgYmV0d2VlbiBhY3Rpb25zXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRydWVcclxuICB9XHJcblxyXG4gIGFzeW5jIHN0YXJ0UmVjb3JkaW5nKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xyXG4gICAgY29uc3QgYWN0aW9ucyA9IFtcclxuICAgICAgKCkgPT4gdGhpcy5zZW5kS2V5Ym9hcmRTaG9ydGN1dCgnUicpXHJcbiAgICBdXHJcblxyXG4gICAgZm9yIChjb25zdCBhY3Rpb24gb2YgYWN0aW9ucykge1xyXG4gICAgICBjb25zdCBzdWNjZXNzID0gYXdhaXQgYWN0aW9uKClcclxuICAgICAgaWYgKCFzdWNjZXNzKSByZXR1cm4gZmFsc2VcclxuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDIwMCkpXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRydWVcclxuICB9XHJcblxyXG4gIGFzeW5jIG9wZW5EZXZpY2VCcm93c2VyKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xyXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VuZEtleWJvYXJkU2hvcnRjdXQoJ0Y0JylcclxuICB9XHJcblxyXG4gIGFzeW5jIHRvZ2dsZUF1dG9tYXRpb24oKTogUHJvbWlzZTxib29sZWFuPiB7XHJcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zZW5kS2V5Ym9hcmRTaG9ydGN1dCgnQScpXHJcbiAgfVxyXG5cclxuICBhc3luYyB0b2dnbGVTbmFwVG9HcmlkKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xyXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VuZEtleWJvYXJkU2hvcnRjdXQoJ1MnKVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgcGxheVN0b3AoKTogUHJvbWlzZTxib29sZWFuPiB7XHJcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zZW5kS2V5Ym9hcmRTaG9ydGN1dCgnU3BhY2UnKVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgdG9nZ2xlTWV0cm9ub21lKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xyXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VuZEtleWJvYXJkU2hvcnRjdXQoJ00nKVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgdW5kbygpOiBQcm9taXNlPGJvb2xlYW4+IHtcclxuICAgIHJldHVybiBhd2FpdCB0aGlzLnNlbmRLZXlib2FyZFNob3J0Y3V0KCdDdHJsK1onKVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgcmVkbygpOiBQcm9taXNlPGJvb2xlYW4+IHtcclxuICAgIHJldHVybiBhd2FpdCB0aGlzLnNlbmRLZXlib2FyZFNob3J0Y3V0KCdDdHJsK1knKVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgc2F2ZVByb2plY3QoKTogUHJvbWlzZTxib29sZWFuPiB7XHJcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zZW5kS2V5Ym9hcmRTaG9ydGN1dCgnQ3RybCtTJylcclxuICB9XHJcblxyXG4gIGFzeW5jIG9wZW5Qcm9qZWN0KCk6IFByb21pc2U8Ym9vbGVhbj4ge1xyXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VuZEtleWJvYXJkU2hvcnRjdXQoJ0N0cmwrTycpXHJcbiAgfVxyXG5cclxuICBhc3luYyBleHBvcnRBdWRpbygpOiBQcm9taXNlPGJvb2xlYW4+IHtcclxuICAgIHJldHVybiBhd2FpdCB0aGlzLnNlbmRLZXlib2FyZFNob3J0Y3V0KCdDdHJsK0UnKVxyXG4gIH1cclxuXHJcbiAgLy8gVXRpbGl0eSBtZXRob2RzXHJcbiAgaXNTdXBwb3J0ZWQoKTogYm9vbGVhbiB7XHJcbiAgICAvLyBPbmx5IHN1cHBvcnQgV2luZG93cyBhbmQgb25seSBpbiBOb2RlLmpzIChub3QgYnJvd3NlcilcclxuICAgIHJldHVybiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJ1xyXG4gIH1cclxuXHJcbiAgZ2V0UGxhdGZvcm0oKTogc3RyaW5nIHtcclxuICAgIHJldHVybiBwcm9jZXNzLnBsYXRmb3JtXHJcbiAgfVxyXG59ICJdLCJuYW1lcyI6WyJTeXN0ZW1JbnRlZ3JhdGlvbiIsImV4ZWN1dGVTeXN0ZW1BY3Rpb24iLCJhY3Rpb24iLCJpc1dpbmRvd3MiLCJjb25zb2xlIiwid2FybiIsInR5cGUiLCJwZXJmb3JtTW91c2VDbGljayIsIngiLCJ5IiwicGVyZm9ybU1vdXNlRHJhZyIsImVuZFgiLCJlbmRZIiwicGVyZm9ybUtleWJvYXJkQWN0aW9uIiwia2V5cyIsImZvY3VzV2luZG93Iiwid2luZG93VGl0bGUiLCJjaGVja1Byb2Nlc3NSdW5uaW5nIiwicHJvY2Vzc05hbWUiLCJlcnJvciIsImxvZyIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsInN0YXJ0WCIsInN0YXJ0WSIsImJhc2VVcmwiLCJ3aW5kb3ciLCJsb2NhdGlvbiIsIm9yaWdpbiIsInJlc3BvbnNlIiwiZmV0Y2giLCJkYXRhIiwianNvbiIsImlzUnVubmluZyIsImZvY3VzQml0d2lnU3R1ZGlvIiwiY2hlY2tCaXR3aWdSdW5uaW5nIiwic2VuZEtleWJvYXJkU2hvcnRjdXQiLCJzaG9ydGN1dCIsImZvY3VzZWQiLCJjbGlja0luQml0d2lnIiwiZHJhZ0luQml0d2lnIiwiY3JlYXRlTmV3UHJvamVjdCIsImFjdGlvbnMiLCJzdWNjZXNzIiwic3RhcnRSZWNvcmRpbmciLCJvcGVuRGV2aWNlQnJvd3NlciIsInRvZ2dsZUF1dG9tYXRpb24iLCJ0b2dnbGVTbmFwVG9HcmlkIiwicGxheVN0b3AiLCJ0b2dnbGVNZXRyb25vbWUiLCJ1bmRvIiwicmVkbyIsInNhdmVQcm9qZWN0Iiwib3BlblByb2plY3QiLCJleHBvcnRBdWRpbyIsImlzU3VwcG9ydGVkIiwicHJvY2VzcyIsInBsYXRmb3JtIiwiZ2V0UGxhdGZvcm0iLCJjb25zdHJ1Y3RvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/lib/system-integration.ts\n"));

/***/ })

});