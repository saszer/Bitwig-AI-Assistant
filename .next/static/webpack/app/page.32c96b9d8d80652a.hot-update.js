"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./app/lib/bitwig-controller.ts":
/*!**************************************!*\
  !*** ./app/lib/bitwig-controller.ts ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BitwigController: function() { return /* binding */ BitwigController; }\n/* harmony export */ });\nclass BitwigController {\n    async initializeConnection() {\n        try {\n            console.log(\"BitwigController: Initializing connection...\");\n            // Check if we're in browser environment\n            if (false) {}\n            // Use API route to check Bitwig status\n            const baseUrl = window.location.origin;\n            console.log(\"BitwigController: Checking Bitwig via API...\");\n            const response = await fetch(\"\".concat(baseUrl, \"/api/check-bitwig\"));\n            const data = await response.json();\n            this.isConnected = data.isRunning;\n            this.isInitialized = true;\n            if (this.isConnected) {\n                console.log(\"BitwigController: Bitwig Studio detected and ready for control\");\n            } else {\n                console.log(\"BitwigController: Bitwig Studio not detected. Please start Bitwig Studio first.\");\n            }\n        } catch (error) {\n            console.error(\"BitwigController: Failed to initialize Bitwig connection:\", error);\n            this.isConnected = false;\n            this.isInitialized = true;\n        }\n    }\n    async checkBitwigRunning() {\n        // Use API route instead of SystemIntegration\n        if (false) {}\n        try {\n            const baseUrl = window.location.origin;\n            const response = await fetch(\"\".concat(baseUrl, \"/api/check-bitwig\"));\n            const data = await response.json();\n            return data.isRunning;\n        } catch (error) {\n            console.error(\"BitwigController: Failed to check Bitwig status:\", error);\n            return false;\n        }\n    }\n    async executeAction(action) {\n        if (!this.isConnected) {\n            return {\n                success: false,\n                message: \"Bitwig Studio is not running. Please start Bitwig Studio first.\"\n            };\n        }\n        try {\n            switch(action.type){\n                case \"click\":\n                    return await this.performClick(action);\n                case \"drag\":\n                    return await this.performDrag(action);\n                case \"keyboard\":\n                    return await this.performKeyboardAction(action);\n                case \"menu\":\n                    return await this.performMenuAction(action);\n                case \"parameter\":\n                    return await this.performParameterAction(action);\n                case \"device\":\n                    return await this.performDeviceAction(action);\n                case \"track\":\n                    return await this.performTrackAction(action);\n                default:\n                    return {\n                        success: false,\n                        message: \"Unknown action type: \".concat(action.type)\n                    };\n            }\n        } catch (error) {\n            return {\n                success: false,\n                message: \"Failed to execute action: \".concat(error)\n            };\n        }\n    }\n    async performClick(action) {\n        if (action.coordinates) {\n            const success = await this.systemIntegration.clickInBitwig(action.coordinates.x, action.coordinates.y);\n            if (success) {\n                return {\n                    success: true,\n                    message: \"Clicked \".concat(action.target, \" at coordinates (\").concat(action.coordinates.x, \", \").concat(action.coordinates.y, \")\")\n                };\n            } else {\n                return {\n                    success: false,\n                    message: \"Failed to click at coordinates (\".concat(action.coordinates.x, \", \").concat(action.coordinates.y, \")\")\n                };\n            }\n        }\n        return {\n            success: false,\n            message: \"No coordinates provided for click action\"\n        };\n    }\n    async performDrag(action) {\n        if (action.coordinates && action.value) {\n            const success = await this.systemIntegration.dragInBitwig(action.coordinates.x, action.coordinates.y, action.value.x, action.value.y);\n            if (success) {\n                return {\n                    success: true,\n                    message: \"Dragged from (\".concat(action.coordinates.x, \", \").concat(action.coordinates.y, \") to (\").concat(action.value.x, \", \").concat(action.value.y, \")\")\n                };\n            } else {\n                return {\n                    success: false,\n                    message: \"Failed to drag from (\".concat(action.coordinates.x, \", \").concat(action.coordinates.y, \") to (\").concat(action.value.x, \", \").concat(action.value.y, \")\")\n                };\n            }\n        }\n        return {\n            success: false,\n            message: \"Invalid drag parameters\"\n        };\n    }\n    async performKeyboardAction(action) {\n        const success = await this.systemIntegration.sendKeyboardShortcut(action.target);\n        if (success) {\n            return {\n                success: true,\n                message: \"Sent keyboard input: \".concat(action.target)\n            };\n        } else {\n            return {\n                success: false,\n                message: \"Failed to send keyboard input: \".concat(action.target)\n            };\n        }\n    }\n    async performMenuAction(action) {\n        // Menu actions are typically keyboard shortcuts or clicks\n        // For now, we'll treat them as keyboard actions\n        return await this.performKeyboardAction(action);\n    }\n    async performParameterAction(action) {\n        // Parameter actions might involve clicking on UI elements\n        // For now, we'll simulate them\n        console.log(\"Setting parameter \".concat(action.target, \" to \").concat(action.value));\n        // In a real implementation, this would:\n        // 1. Find the parameter control in the UI\n        // 2. Click on it or drag to set the value\n        // 3. Update the parameter\n        await new Promise((resolve)=>setTimeout(resolve, 100));\n        return {\n            success: true,\n            message: \"Set parameter \".concat(action.target, \" to \").concat(action.value)\n        };\n    }\n    async performDeviceAction(action) {\n        // Device actions might involve:\n        // - Opening device browser (F4)\n        // - Clicking to add devices\n        // - Dragging devices to tracks\n        switch(action.target){\n            case \"add_eq_device\":\n                // Open device browser and add EQ\n                const browserSuccess = await this.systemIntegration.openDeviceBrowser();\n                if (!browserSuccess) {\n                    return {\n                        success: false,\n                        message: \"Failed to open device browser\"\n                    };\n                }\n                // Wait for browser to open, then click EQ device\n                await new Promise((resolve)=>setTimeout(resolve, 500));\n                // This would click on the EQ device in the browser\n                // For now, we'll simulate success\n                return {\n                    success: true,\n                    message: \"EQ+ device added to track\"\n                };\n            case \"add_selected_device\":\n                // This would drag the selected device to the track\n                return {\n                    success: true,\n                    message: \"Selected device added to track\"\n                };\n            default:\n                return {\n                    success: true,\n                    message: \"Device action completed: \".concat(action.target)\n                };\n        }\n    }\n    async performTrackAction(action) {\n        // Track actions might involve:\n        // - Right-clicking to add tracks\n        // - Clicking track controls\n        // - Managing track settings\n        switch(action.target){\n            case \"add_midi_track\":\n                // This would right-click in track list and select \"Add MIDI Track\"\n                // For now, we'll simulate the action\n                await new Promise((resolve)=>setTimeout(resolve, 100));\n                return {\n                    success: true,\n                    message: \"MIDI track added successfully\"\n                };\n            default:\n                return {\n                    success: true,\n                    message: \"Track action completed: \".concat(action.target)\n                };\n        }\n    }\n    // High-level action methods\n    async createNewProject() {\n        const success = await this.systemIntegration.createNewProject();\n        if (success) {\n            return {\n                success: true,\n                message: \"New project created successfully\"\n            };\n        } else {\n            return {\n                success: false,\n                message: \"Failed to create new project\"\n            };\n        }\n    }\n    async recordAudio() {\n        const actions = [\n            {\n                type: \"click\",\n                target: \"record_arm_button\",\n                coordinates: {\n                    x: 150,\n                    y: 100\n                },\n                description: \"Arm track for recording\"\n            },\n            {\n                type: \"click\",\n                target: \"main_record_button\",\n                coordinates: {\n                    x: 400,\n                    y: 50\n                },\n                description: \"Start recording\"\n            }\n        ];\n        for (const action of actions){\n            const result = await this.executeAction(action);\n            if (!result.success) return result;\n            await new Promise((resolve)=>setTimeout(resolve, 200));\n        }\n        return {\n            success: true,\n            message: \"Audio recording started\"\n        };\n    }\n    async addEQDevice() {\n        const action = {\n            type: \"device\",\n            target: \"add_eq_device\",\n            description: \"Add EQ+ device to track\"\n        };\n        return await this.executeAction(action);\n    }\n    async setTrackVolume(trackIndex, volume) {\n        const action = {\n            type: \"parameter\",\n            target: \"track_volume\",\n            value: volume,\n            description: \"Set track \".concat(trackIndex, \" volume to \").concat(volume, \"dB\")\n        };\n        return await this.executeAction(action);\n    }\n    async enableAutomation() {\n        const success = await this.systemIntegration.toggleAutomation();\n        if (success) {\n            return {\n                success: true,\n                message: \"Automation mode enabled\"\n            };\n        } else {\n            return {\n                success: false,\n                message: \"Failed to enable automation\"\n            };\n        }\n    }\n    // Additional Bitwig control methods\n    async playStop() {\n        const success = await this.systemIntegration.playStop();\n        return {\n            success,\n            message: success ? \"Playback toggled\" : \"Failed to toggle playback\"\n        };\n    }\n    async toggleMetronome() {\n        const success = await this.systemIntegration.toggleMetronome();\n        return {\n            success,\n            message: success ? \"Metronome toggled\" : \"Failed to toggle metronome\"\n        };\n    }\n    async undo() {\n        const success = await this.systemIntegration.undo();\n        return {\n            success,\n            message: success ? \"Undo performed\" : \"Failed to undo\"\n        };\n    }\n    async redo() {\n        const success = await this.systemIntegration.redo();\n        return {\n            success,\n            message: success ? \"Redo performed\" : \"Failed to redo\"\n        };\n    }\n    async saveProject() {\n        const success = await this.systemIntegration.saveProject();\n        return {\n            success,\n            message: success ? \"Project saved\" : \"Failed to save project\"\n        };\n    }\n    async openProject() {\n        const success = await this.systemIntegration.openProject();\n        return {\n            success,\n            message: success ? \"Project opened\" : \"Failed to open project\"\n        };\n    }\n    async exportAudio() {\n        const success = await this.systemIntegration.exportAudio();\n        return {\n            success,\n            message: success ? \"Audio export started\" : \"Failed to start audio export\"\n        };\n    }\n    getConnectionStatus() {\n        return this.isConnected && this.isInitialized;\n    }\n    isInitializationComplete() {\n        return this.isInitialized;\n    }\n    async waitForInitialization() {\n        while(!this.isInitialized){\n            await new Promise((resolve)=>setTimeout(resolve, 100));\n        }\n        return this.isConnected;\n    }\n    async reconnect() {\n        this.isConnected = false;\n        this.isInitialized = false;\n        await this.initializeConnection();\n        return this.isConnected;\n    }\n    getSystemInfo() {\n        return {\n            platform: this.systemIntegration.getPlatform(),\n            supported: this.systemIntegration.isSupported()\n        };\n    }\n    constructor(){\n        this.isConnected = false;\n        this.isInitialized = false;\n        this.actionQueue = [];\n        // Only initialize connection on client side\n        if (true) {\n            this.initializeConnection();\n        }\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9saWIvYml0d2lnLWNvbnRyb2xsZXIudHMiLCJtYXBwaW5ncyI6Ijs7OztBQWNPLE1BQU1BO0lBWVgsTUFBY0MsdUJBQXVCO1FBQ25DLElBQUk7WUFDRkMsUUFBUUMsR0FBRyxDQUFDO1lBRVosd0NBQXdDO1lBQ3hDLElBQUksS0FBa0IsRUFBYSxFQUtsQztZQUVELHVDQUF1QztZQUN2QyxNQUFNRyxVQUFVQyxPQUFPQyxRQUFRLENBQUNDLE1BQU07WUFDdENQLFFBQVFDLEdBQUcsQ0FBQztZQUNaLE1BQU1PLFdBQVcsTUFBTUMsTUFBTSxHQUFXLE9BQVJMLFNBQVE7WUFDeEMsTUFBTU0sT0FBTyxNQUFNRixTQUFTRyxJQUFJO1lBRWhDLElBQUksQ0FBQ1QsV0FBVyxHQUFHUSxLQUFLRSxTQUFTO1lBQ2pDLElBQUksQ0FBQ1QsYUFBYSxHQUFHO1lBRXJCLElBQUksSUFBSSxDQUFDRCxXQUFXLEVBQUU7Z0JBQ3BCRixRQUFRQyxHQUFHLENBQUM7WUFDZCxPQUFPO2dCQUNMRCxRQUFRQyxHQUFHLENBQUM7WUFDZDtRQUNGLEVBQUUsT0FBT1ksT0FBTztZQUNkYixRQUFRYSxLQUFLLENBQUMsNkRBQTZEQTtZQUMzRSxJQUFJLENBQUNYLFdBQVcsR0FBRztZQUNuQixJQUFJLENBQUNDLGFBQWEsR0FBRztRQUN2QjtJQUNGO0lBRUEsTUFBY1cscUJBQXVDO1FBQ25ELDZDQUE2QztRQUM3QyxJQUFJLEtBQWtCLEVBQWEsRUFFbEM7UUFFRCxJQUFJO1lBQ0YsTUFBTVYsVUFBVUMsT0FBT0MsUUFBUSxDQUFDQyxNQUFNO1lBQ3RDLE1BQU1DLFdBQVcsTUFBTUMsTUFBTSxHQUFXLE9BQVJMLFNBQVE7WUFDeEMsTUFBTU0sT0FBTyxNQUFNRixTQUFTRyxJQUFJO1lBQ2hDLE9BQU9ELEtBQUtFLFNBQVM7UUFDdkIsRUFBRSxPQUFPQyxPQUFPO1lBQ2RiLFFBQVFhLEtBQUssQ0FBQyxvREFBb0RBO1lBQ2xFLE9BQU87UUFDVDtJQUNGO0lBRUEsTUFBTUUsY0FBY0MsTUFBb0IsRUFBMkI7UUFDakUsSUFBSSxDQUFDLElBQUksQ0FBQ2QsV0FBVyxFQUFFO1lBQ3JCLE9BQU87Z0JBQ0xlLFNBQVM7Z0JBQ1RDLFNBQVM7WUFDWDtRQUNGO1FBRUEsSUFBSTtZQUNGLE9BQVFGLE9BQU9HLElBQUk7Z0JBQ2pCLEtBQUs7b0JBQ0gsT0FBTyxNQUFNLElBQUksQ0FBQ0MsWUFBWSxDQUFDSjtnQkFDakMsS0FBSztvQkFDSCxPQUFPLE1BQU0sSUFBSSxDQUFDSyxXQUFXLENBQUNMO2dCQUNoQyxLQUFLO29CQUNILE9BQU8sTUFBTSxJQUFJLENBQUNNLHFCQUFxQixDQUFDTjtnQkFDMUMsS0FBSztvQkFDSCxPQUFPLE1BQU0sSUFBSSxDQUFDTyxpQkFBaUIsQ0FBQ1A7Z0JBQ3RDLEtBQUs7b0JBQ0gsT0FBTyxNQUFNLElBQUksQ0FBQ1Esc0JBQXNCLENBQUNSO2dCQUMzQyxLQUFLO29CQUNILE9BQU8sTUFBTSxJQUFJLENBQUNTLG1CQUFtQixDQUFDVDtnQkFDeEMsS0FBSztvQkFDSCxPQUFPLE1BQU0sSUFBSSxDQUFDVSxrQkFBa0IsQ0FBQ1Y7Z0JBQ3ZDO29CQUNFLE9BQU87d0JBQ0xDLFNBQVM7d0JBQ1RDLFNBQVMsd0JBQW9DLE9BQVpGLE9BQU9HLElBQUk7b0JBQzlDO1lBQ0o7UUFDRixFQUFFLE9BQU9OLE9BQU87WUFDZCxPQUFPO2dCQUNMSSxTQUFTO2dCQUNUQyxTQUFTLDZCQUFtQyxPQUFOTDtZQUN4QztRQUNGO0lBQ0Y7SUFFQSxNQUFjTyxhQUFhSixNQUFvQixFQUEyQjtRQUN4RSxJQUFJQSxPQUFPVyxXQUFXLEVBQUU7WUFDdEIsTUFBTVYsVUFBVSxNQUFNLElBQUksQ0FBQ1csaUJBQWlCLENBQUNDLGFBQWEsQ0FDeERiLE9BQU9XLFdBQVcsQ0FBQ0csQ0FBQyxFQUNwQmQsT0FBT1csV0FBVyxDQUFDSSxDQUFDO1lBR3RCLElBQUlkLFNBQVM7Z0JBQ1gsT0FBTztvQkFDTEEsU0FBUztvQkFDVEMsU0FBUyxXQUE0Q0YsT0FBakNBLE9BQU9nQixNQUFNLEVBQUMscUJBQTRDaEIsT0FBekJBLE9BQU9XLFdBQVcsQ0FBQ0csQ0FBQyxFQUFDLE1BQXlCLE9BQXJCZCxPQUFPVyxXQUFXLENBQUNJLENBQUMsRUFBQztnQkFDckc7WUFDRixPQUFPO2dCQUNMLE9BQU87b0JBQ0xkLFNBQVM7b0JBQ1RDLFNBQVMsbUNBQTRERixPQUF6QkEsT0FBT1csV0FBVyxDQUFDRyxDQUFDLEVBQUMsTUFBeUIsT0FBckJkLE9BQU9XLFdBQVcsQ0FBQ0ksQ0FBQyxFQUFDO2dCQUM1RjtZQUNGO1FBQ0Y7UUFFQSxPQUFPO1lBQ0xkLFNBQVM7WUFDVEMsU0FBUztRQUNYO0lBQ0Y7SUFFQSxNQUFjRyxZQUFZTCxNQUFvQixFQUEyQjtRQUN2RSxJQUFJQSxPQUFPVyxXQUFXLElBQUlYLE9BQU9pQixLQUFLLEVBQUU7WUFDdEMsTUFBTWhCLFVBQVUsTUFBTSxJQUFJLENBQUNXLGlCQUFpQixDQUFDTSxZQUFZLENBQ3ZEbEIsT0FBT1csV0FBVyxDQUFDRyxDQUFDLEVBQ3BCZCxPQUFPVyxXQUFXLENBQUNJLENBQUMsRUFDcEJmLE9BQU9pQixLQUFLLENBQUNILENBQUMsRUFDZGQsT0FBT2lCLEtBQUssQ0FBQ0YsQ0FBQztZQUdoQixJQUFJZCxTQUFTO2dCQUNYLE9BQU87b0JBQ0xBLFNBQVM7b0JBQ1RDLFNBQVMsaUJBQTBDRixPQUF6QkEsT0FBT1csV0FBVyxDQUFDRyxDQUFDLEVBQUMsTUFBaUNkLE9BQTdCQSxPQUFPVyxXQUFXLENBQUNJLENBQUMsRUFBQyxVQUEyQmYsT0FBbkJBLE9BQU9pQixLQUFLLENBQUNILENBQUMsRUFBQyxNQUFtQixPQUFmZCxPQUFPaUIsS0FBSyxDQUFDRixDQUFDLEVBQUM7Z0JBQ3BIO1lBQ0YsT0FBTztnQkFDTCxPQUFPO29CQUNMZCxTQUFTO29CQUNUQyxTQUFTLHdCQUFpREYsT0FBekJBLE9BQU9XLFdBQVcsQ0FBQ0csQ0FBQyxFQUFDLE1BQWlDZCxPQUE3QkEsT0FBT1csV0FBVyxDQUFDSSxDQUFDLEVBQUMsVUFBMkJmLE9BQW5CQSxPQUFPaUIsS0FBSyxDQUFDSCxDQUFDLEVBQUMsTUFBbUIsT0FBZmQsT0FBT2lCLEtBQUssQ0FBQ0YsQ0FBQyxFQUFDO2dCQUMzSDtZQUNGO1FBQ0Y7UUFFQSxPQUFPO1lBQ0xkLFNBQVM7WUFDVEMsU0FBUztRQUNYO0lBQ0Y7SUFFQSxNQUFjSSxzQkFBc0JOLE1BQW9CLEVBQTJCO1FBQ2pGLE1BQU1DLFVBQVUsTUFBTSxJQUFJLENBQUNXLGlCQUFpQixDQUFDTyxvQkFBb0IsQ0FBQ25CLE9BQU9nQixNQUFNO1FBRS9FLElBQUlmLFNBQVM7WUFDWCxPQUFPO2dCQUNMQSxTQUFTO2dCQUNUQyxTQUFTLHdCQUFzQyxPQUFkRixPQUFPZ0IsTUFBTTtZQUNoRDtRQUNGLE9BQU87WUFDTCxPQUFPO2dCQUNMZixTQUFTO2dCQUNUQyxTQUFTLGtDQUFnRCxPQUFkRixPQUFPZ0IsTUFBTTtZQUMxRDtRQUNGO0lBQ0Y7SUFFQSxNQUFjVCxrQkFBa0JQLE1BQW9CLEVBQTJCO1FBQzdFLDBEQUEwRDtRQUMxRCxnREFBZ0Q7UUFDaEQsT0FBTyxNQUFNLElBQUksQ0FBQ00scUJBQXFCLENBQUNOO0lBQzFDO0lBRUEsTUFBY1EsdUJBQXVCUixNQUFvQixFQUEyQjtRQUNsRiwwREFBMEQ7UUFDMUQsK0JBQStCO1FBQy9CaEIsUUFBUUMsR0FBRyxDQUFDLHFCQUF5Q2UsT0FBcEJBLE9BQU9nQixNQUFNLEVBQUMsUUFBbUIsT0FBYmhCLE9BQU9pQixLQUFLO1FBRWpFLHdDQUF3QztRQUN4QywwQ0FBMEM7UUFDMUMsMENBQTBDO1FBQzFDLDBCQUEwQjtRQUUxQixNQUFNLElBQUlHLFFBQVFDLENBQUFBLFVBQVdDLFdBQVdELFNBQVM7UUFFakQsT0FBTztZQUNMcEIsU0FBUztZQUNUQyxTQUFTLGlCQUFxQ0YsT0FBcEJBLE9BQU9nQixNQUFNLEVBQUMsUUFBbUIsT0FBYmhCLE9BQU9pQixLQUFLO1FBQzVEO0lBQ0Y7SUFFQSxNQUFjUixvQkFBb0JULE1BQW9CLEVBQTJCO1FBQy9FLGdDQUFnQztRQUNoQyxnQ0FBZ0M7UUFDaEMsNEJBQTRCO1FBQzVCLCtCQUErQjtRQUUvQixPQUFRQSxPQUFPZ0IsTUFBTTtZQUNuQixLQUFLO2dCQUNILGlDQUFpQztnQkFDakMsTUFBTU8saUJBQWlCLE1BQU0sSUFBSSxDQUFDWCxpQkFBaUIsQ0FBQ1ksaUJBQWlCO2dCQUNyRSxJQUFJLENBQUNELGdCQUFnQjtvQkFDbkIsT0FBTzt3QkFDTHRCLFNBQVM7d0JBQ1RDLFNBQVM7b0JBQ1g7Z0JBQ0Y7Z0JBRUEsaURBQWlEO2dCQUNqRCxNQUFNLElBQUlrQixRQUFRQyxDQUFBQSxVQUFXQyxXQUFXRCxTQUFTO2dCQUVqRCxtREFBbUQ7Z0JBQ25ELGtDQUFrQztnQkFDbEMsT0FBTztvQkFDTHBCLFNBQVM7b0JBQ1RDLFNBQVM7Z0JBQ1g7WUFFRixLQUFLO2dCQUNILG1EQUFtRDtnQkFDbkQsT0FBTztvQkFDTEQsU0FBUztvQkFDVEMsU0FBUztnQkFDWDtZQUVGO2dCQUNFLE9BQU87b0JBQ0xELFNBQVM7b0JBQ1RDLFNBQVMsNEJBQTBDLE9BQWRGLE9BQU9nQixNQUFNO2dCQUNwRDtRQUNKO0lBQ0Y7SUFFQSxNQUFjTixtQkFBbUJWLE1BQW9CLEVBQTJCO1FBQzlFLCtCQUErQjtRQUMvQixpQ0FBaUM7UUFDakMsNEJBQTRCO1FBQzVCLDRCQUE0QjtRQUU1QixPQUFRQSxPQUFPZ0IsTUFBTTtZQUNuQixLQUFLO2dCQUNILG1FQUFtRTtnQkFDbkUscUNBQXFDO2dCQUNyQyxNQUFNLElBQUlJLFFBQVFDLENBQUFBLFVBQVdDLFdBQVdELFNBQVM7Z0JBQ2pELE9BQU87b0JBQ0xwQixTQUFTO29CQUNUQyxTQUFTO2dCQUNYO1lBRUY7Z0JBQ0UsT0FBTztvQkFDTEQsU0FBUztvQkFDVEMsU0FBUywyQkFBeUMsT0FBZEYsT0FBT2dCLE1BQU07Z0JBQ25EO1FBQ0o7SUFDRjtJQUVBLDRCQUE0QjtJQUM1QixNQUFNUyxtQkFBNEM7UUFDaEQsTUFBTXhCLFVBQVUsTUFBTSxJQUFJLENBQUNXLGlCQUFpQixDQUFDYSxnQkFBZ0I7UUFFN0QsSUFBSXhCLFNBQVM7WUFDWCxPQUFPO2dCQUNMQSxTQUFTO2dCQUNUQyxTQUFTO1lBQ1g7UUFDRixPQUFPO1lBQ0wsT0FBTztnQkFDTEQsU0FBUztnQkFDVEMsU0FBUztZQUNYO1FBQ0Y7SUFDRjtJQUVBLE1BQU13QixjQUF1QztRQUMzQyxNQUFNQyxVQUFVO1lBQ2Q7Z0JBQ0V4QixNQUFNO2dCQUNOYSxRQUFRO2dCQUNSTCxhQUFhO29CQUFFRyxHQUFHO29CQUFLQyxHQUFHO2dCQUFJO2dCQUM5QmEsYUFBYTtZQUNmO1lBQ0E7Z0JBQ0V6QixNQUFNO2dCQUNOYSxRQUFRO2dCQUNSTCxhQUFhO29CQUFFRyxHQUFHO29CQUFLQyxHQUFHO2dCQUFHO2dCQUM3QmEsYUFBYTtZQUNmO1NBQ0Q7UUFFRCxLQUFLLE1BQU01QixVQUFVMkIsUUFBUztZQUM1QixNQUFNRSxTQUFTLE1BQU0sSUFBSSxDQUFDOUIsYUFBYSxDQUFDQztZQUN4QyxJQUFJLENBQUM2QixPQUFPNUIsT0FBTyxFQUFFLE9BQU80QjtZQUM1QixNQUFNLElBQUlULFFBQVFDLENBQUFBLFVBQVdDLFdBQVdELFNBQVM7UUFDbkQ7UUFFQSxPQUFPO1lBQ0xwQixTQUFTO1lBQ1RDLFNBQVM7UUFDWDtJQUNGO0lBRUEsTUFBTTRCLGNBQXVDO1FBQzNDLE1BQU05QixTQUF1QjtZQUMzQkcsTUFBTTtZQUNOYSxRQUFRO1lBQ1JZLGFBQWE7UUFDZjtRQUVBLE9BQU8sTUFBTSxJQUFJLENBQUM3QixhQUFhLENBQUNDO0lBQ2xDO0lBRUEsTUFBTStCLGVBQWVDLFVBQWtCLEVBQUVDLE1BQWMsRUFBMkI7UUFDaEYsTUFBTWpDLFNBQXVCO1lBQzNCRyxNQUFNO1lBQ05hLFFBQVE7WUFDUkMsT0FBT2dCO1lBQ1BMLGFBQWEsYUFBcUNLLE9BQXhCRCxZQUFXLGVBQW9CLE9BQVBDLFFBQU87UUFDM0Q7UUFFQSxPQUFPLE1BQU0sSUFBSSxDQUFDbEMsYUFBYSxDQUFDQztJQUNsQztJQUVBLE1BQU1rQyxtQkFBNEM7UUFDaEQsTUFBTWpDLFVBQVUsTUFBTSxJQUFJLENBQUNXLGlCQUFpQixDQUFDdUIsZ0JBQWdCO1FBRTdELElBQUlsQyxTQUFTO1lBQ1gsT0FBTztnQkFDTEEsU0FBUztnQkFDVEMsU0FBUztZQUNYO1FBQ0YsT0FBTztZQUNMLE9BQU87Z0JBQ0xELFNBQVM7Z0JBQ1RDLFNBQVM7WUFDWDtRQUNGO0lBQ0Y7SUFFQSxvQ0FBb0M7SUFDcEMsTUFBTWtDLFdBQW9DO1FBQ3hDLE1BQU1uQyxVQUFVLE1BQU0sSUFBSSxDQUFDVyxpQkFBaUIsQ0FBQ3dCLFFBQVE7UUFFckQsT0FBTztZQUNMbkM7WUFDQUMsU0FBU0QsVUFBVSxxQkFBcUI7UUFDMUM7SUFDRjtJQUVBLE1BQU1vQyxrQkFBMkM7UUFDL0MsTUFBTXBDLFVBQVUsTUFBTSxJQUFJLENBQUNXLGlCQUFpQixDQUFDeUIsZUFBZTtRQUU1RCxPQUFPO1lBQ0xwQztZQUNBQyxTQUFTRCxVQUFVLHNCQUFzQjtRQUMzQztJQUNGO0lBRUEsTUFBTXFDLE9BQWdDO1FBQ3BDLE1BQU1yQyxVQUFVLE1BQU0sSUFBSSxDQUFDVyxpQkFBaUIsQ0FBQzBCLElBQUk7UUFFakQsT0FBTztZQUNMckM7WUFDQUMsU0FBU0QsVUFBVSxtQkFBbUI7UUFDeEM7SUFDRjtJQUVBLE1BQU1zQyxPQUFnQztRQUNwQyxNQUFNdEMsVUFBVSxNQUFNLElBQUksQ0FBQ1csaUJBQWlCLENBQUMyQixJQUFJO1FBRWpELE9BQU87WUFDTHRDO1lBQ0FDLFNBQVNELFVBQVUsbUJBQW1CO1FBQ3hDO0lBQ0Y7SUFFQSxNQUFNdUMsY0FBdUM7UUFDM0MsTUFBTXZDLFVBQVUsTUFBTSxJQUFJLENBQUNXLGlCQUFpQixDQUFDNEIsV0FBVztRQUV4RCxPQUFPO1lBQ0x2QztZQUNBQyxTQUFTRCxVQUFVLGtCQUFrQjtRQUN2QztJQUNGO0lBRUEsTUFBTXdDLGNBQXVDO1FBQzNDLE1BQU14QyxVQUFVLE1BQU0sSUFBSSxDQUFDVyxpQkFBaUIsQ0FBQzZCLFdBQVc7UUFFeEQsT0FBTztZQUNMeEM7WUFDQUMsU0FBU0QsVUFBVSxtQkFBbUI7UUFDeEM7SUFDRjtJQUVBLE1BQU15QyxjQUF1QztRQUMzQyxNQUFNekMsVUFBVSxNQUFNLElBQUksQ0FBQ1csaUJBQWlCLENBQUM4QixXQUFXO1FBRXhELE9BQU87WUFDTHpDO1lBQ0FDLFNBQVNELFVBQVUseUJBQXlCO1FBQzlDO0lBQ0Y7SUFFQTBDLHNCQUErQjtRQUM3QixPQUFPLElBQUksQ0FBQ3pELFdBQVcsSUFBSSxJQUFJLENBQUNDLGFBQWE7SUFDL0M7SUFFQXlELDJCQUFvQztRQUNsQyxPQUFPLElBQUksQ0FBQ3pELGFBQWE7SUFDM0I7SUFFQSxNQUFNMEQsd0JBQTBDO1FBQzlDLE1BQU8sQ0FBQyxJQUFJLENBQUMxRCxhQUFhLENBQUU7WUFDMUIsTUFBTSxJQUFJaUMsUUFBUUMsQ0FBQUEsVUFBV0MsV0FBV0QsU0FBUztRQUNuRDtRQUNBLE9BQU8sSUFBSSxDQUFDbkMsV0FBVztJQUN6QjtJQUVBLE1BQU00RCxZQUE4QjtRQUNsQyxJQUFJLENBQUM1RCxXQUFXLEdBQUc7UUFDbkIsSUFBSSxDQUFDQyxhQUFhLEdBQUc7UUFDckIsTUFBTSxJQUFJLENBQUNKLG9CQUFvQjtRQUMvQixPQUFPLElBQUksQ0FBQ0csV0FBVztJQUN6QjtJQUVBNkQsZ0JBQTBEO1FBQ3hELE9BQU87WUFDTEMsVUFBVSxJQUFJLENBQUNwQyxpQkFBaUIsQ0FBQ3FDLFdBQVc7WUFDNUNDLFdBQVcsSUFBSSxDQUFDdEMsaUJBQWlCLENBQUN1QyxXQUFXO1FBQy9DO0lBQ0Y7SUE1YUFDLGFBQWM7YUFKTmxFLGNBQXVCO2FBQ3ZCQyxnQkFBeUI7YUFDekJrRSxjQUE4QixFQUFFO1FBR3RDLDRDQUE0QztRQUM1QyxJQUFJLElBQWtCLEVBQWE7WUFDakMsSUFBSSxDQUFDdEUsb0JBQW9CO1FBQzNCO0lBQ0Y7QUF3YUYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwL2xpYi9iaXR3aWctY29udHJvbGxlci50cz8wNTYzIl0sInNvdXJjZXNDb250ZW50IjpbImludGVyZmFjZSBCaXR3aWdBY3Rpb24ge1xyXG4gIHR5cGU6ICdjbGljaycgfCAnZHJhZycgfCAna2V5Ym9hcmQnIHwgJ21lbnUnIHwgJ3BhcmFtZXRlcicgfCAnZGV2aWNlJyB8ICd0cmFjaydcclxuICB0YXJnZXQ6IHN0cmluZ1xyXG4gIHZhbHVlPzogYW55XHJcbiAgY29vcmRpbmF0ZXM/OiB7IHg6IG51bWJlcjsgeTogbnVtYmVyIH1cclxuICBkZXNjcmlwdGlvbjogc3RyaW5nXHJcbn1cclxuXHJcbmludGVyZmFjZSBCaXR3aWdSZXNwb25zZSB7XHJcbiAgc3VjY2VzczogYm9vbGVhblxyXG4gIG1lc3NhZ2U6IHN0cmluZ1xyXG4gIGRhdGE/OiBhbnlcclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIEJpdHdpZ0NvbnRyb2xsZXIge1xyXG4gIHByaXZhdGUgaXNDb25uZWN0ZWQ6IGJvb2xlYW4gPSBmYWxzZVxyXG4gIHByaXZhdGUgaXNJbml0aWFsaXplZDogYm9vbGVhbiA9IGZhbHNlXHJcbiAgcHJpdmF0ZSBhY3Rpb25RdWV1ZTogQml0d2lnQWN0aW9uW10gPSBbXVxyXG5cclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIC8vIE9ubHkgaW5pdGlhbGl6ZSBjb25uZWN0aW9uIG9uIGNsaWVudCBzaWRlXHJcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgdGhpcy5pbml0aWFsaXplQ29ubmVjdGlvbigpXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFzeW5jIGluaXRpYWxpemVDb25uZWN0aW9uKCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc29sZS5sb2coJ0JpdHdpZ0NvbnRyb2xsZXI6IEluaXRpYWxpemluZyBjb25uZWN0aW9uLi4uJylcclxuICAgICAgXHJcbiAgICAgIC8vIENoZWNrIGlmIHdlJ3JlIGluIGJyb3dzZXIgZW52aXJvbm1lbnRcclxuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ0JpdHdpZ0NvbnRyb2xsZXI6IE5vdCBpbiBicm93c2VyLCBza2lwcGluZyBpbml0aWFsaXphdGlvbicpXHJcbiAgICAgICAgdGhpcy5pc0Nvbm5lY3RlZCA9IGZhbHNlXHJcbiAgICAgICAgdGhpcy5pc0luaXRpYWxpemVkID0gdHJ1ZVxyXG4gICAgICAgIHJldHVyblxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBVc2UgQVBJIHJvdXRlIHRvIGNoZWNrIEJpdHdpZyBzdGF0dXNcclxuICAgICAgY29uc3QgYmFzZVVybCA9IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW5cclxuICAgICAgY29uc29sZS5sb2coJ0JpdHdpZ0NvbnRyb2xsZXI6IENoZWNraW5nIEJpdHdpZyB2aWEgQVBJLi4uJylcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtiYXNlVXJsfS9hcGkvY2hlY2stYml0d2lnYClcclxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxyXG4gICAgICBcclxuICAgICAgdGhpcy5pc0Nvbm5lY3RlZCA9IGRhdGEuaXNSdW5uaW5nXHJcbiAgICAgIHRoaXMuaXNJbml0aWFsaXplZCA9IHRydWVcclxuICAgICAgXHJcbiAgICAgIGlmICh0aGlzLmlzQ29ubmVjdGVkKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ0JpdHdpZ0NvbnRyb2xsZXI6IEJpdHdpZyBTdHVkaW8gZGV0ZWN0ZWQgYW5kIHJlYWR5IGZvciBjb250cm9sJylcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zb2xlLmxvZygnQml0d2lnQ29udHJvbGxlcjogQml0d2lnIFN0dWRpbyBub3QgZGV0ZWN0ZWQuIFBsZWFzZSBzdGFydCBCaXR3aWcgU3R1ZGlvIGZpcnN0LicpXHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0JpdHdpZ0NvbnRyb2xsZXI6IEZhaWxlZCB0byBpbml0aWFsaXplIEJpdHdpZyBjb25uZWN0aW9uOicsIGVycm9yKVxyXG4gICAgICB0aGlzLmlzQ29ubmVjdGVkID0gZmFsc2VcclxuICAgICAgdGhpcy5pc0luaXRpYWxpemVkID0gdHJ1ZVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBhc3luYyBjaGVja0JpdHdpZ1J1bm5pbmcoKTogUHJvbWlzZTxib29sZWFuPiB7XHJcbiAgICAvLyBVc2UgQVBJIHJvdXRlIGluc3RlYWQgb2YgU3lzdGVtSW50ZWdyYXRpb25cclxuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICByZXR1cm4gZmFsc2VcclxuICAgIH1cclxuICAgIFxyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgYmFzZVVybCA9IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW5cclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtiYXNlVXJsfS9hcGkvY2hlY2stYml0d2lnYClcclxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxyXG4gICAgICByZXR1cm4gZGF0YS5pc1J1bm5pbmdcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0JpdHdpZ0NvbnRyb2xsZXI6IEZhaWxlZCB0byBjaGVjayBCaXR3aWcgc3RhdHVzOicsIGVycm9yKVxyXG4gICAgICByZXR1cm4gZmFsc2VcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGFzeW5jIGV4ZWN1dGVBY3Rpb24oYWN0aW9uOiBCaXR3aWdBY3Rpb24pOiBQcm9taXNlPEJpdHdpZ1Jlc3BvbnNlPiB7XHJcbiAgICBpZiAoIXRoaXMuaXNDb25uZWN0ZWQpIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcclxuICAgICAgICBtZXNzYWdlOiAnQml0d2lnIFN0dWRpbyBpcyBub3QgcnVubmluZy4gUGxlYXNlIHN0YXJ0IEJpdHdpZyBTdHVkaW8gZmlyc3QuJ1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xyXG4gICAgICAgIGNhc2UgJ2NsaWNrJzpcclxuICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnBlcmZvcm1DbGljayhhY3Rpb24pXHJcbiAgICAgICAgY2FzZSAnZHJhZyc6XHJcbiAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wZXJmb3JtRHJhZyhhY3Rpb24pXHJcbiAgICAgICAgY2FzZSAna2V5Ym9hcmQnOlxyXG4gICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucGVyZm9ybUtleWJvYXJkQWN0aW9uKGFjdGlvbilcclxuICAgICAgICBjYXNlICdtZW51JzpcclxuICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnBlcmZvcm1NZW51QWN0aW9uKGFjdGlvbilcclxuICAgICAgICBjYXNlICdwYXJhbWV0ZXInOlxyXG4gICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucGVyZm9ybVBhcmFtZXRlckFjdGlvbihhY3Rpb24pXHJcbiAgICAgICAgY2FzZSAnZGV2aWNlJzpcclxuICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnBlcmZvcm1EZXZpY2VBY3Rpb24oYWN0aW9uKVxyXG4gICAgICAgIGNhc2UgJ3RyYWNrJzpcclxuICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnBlcmZvcm1UcmFja0FjdGlvbihhY3Rpb24pXHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxyXG4gICAgICAgICAgICBtZXNzYWdlOiBgVW5rbm93biBhY3Rpb24gdHlwZTogJHthY3Rpb24udHlwZX1gXHJcbiAgICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXHJcbiAgICAgICAgbWVzc2FnZTogYEZhaWxlZCB0byBleGVjdXRlIGFjdGlvbjogJHtlcnJvcn1gXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgYXN5bmMgcGVyZm9ybUNsaWNrKGFjdGlvbjogQml0d2lnQWN0aW9uKTogUHJvbWlzZTxCaXR3aWdSZXNwb25zZT4ge1xyXG4gICAgaWYgKGFjdGlvbi5jb29yZGluYXRlcykge1xyXG4gICAgICBjb25zdCBzdWNjZXNzID0gYXdhaXQgdGhpcy5zeXN0ZW1JbnRlZ3JhdGlvbi5jbGlja0luQml0d2lnKFxyXG4gICAgICAgIGFjdGlvbi5jb29yZGluYXRlcy54LCBcclxuICAgICAgICBhY3Rpb24uY29vcmRpbmF0ZXMueVxyXG4gICAgICApXHJcbiAgICAgIFxyXG4gICAgICBpZiAoc3VjY2Vzcykge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxyXG4gICAgICAgICAgbWVzc2FnZTogYENsaWNrZWQgJHthY3Rpb24udGFyZ2V0fSBhdCBjb29yZGluYXRlcyAoJHthY3Rpb24uY29vcmRpbmF0ZXMueH0sICR7YWN0aW9uLmNvb3JkaW5hdGVzLnl9KWBcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxyXG4gICAgICAgICAgbWVzc2FnZTogYEZhaWxlZCB0byBjbGljayBhdCBjb29yZGluYXRlcyAoJHthY3Rpb24uY29vcmRpbmF0ZXMueH0sICR7YWN0aW9uLmNvb3JkaW5hdGVzLnl9KWBcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgc3VjY2VzczogZmFsc2UsXHJcbiAgICAgIG1lc3NhZ2U6ICdObyBjb29yZGluYXRlcyBwcm92aWRlZCBmb3IgY2xpY2sgYWN0aW9uJ1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBhc3luYyBwZXJmb3JtRHJhZyhhY3Rpb246IEJpdHdpZ0FjdGlvbik6IFByb21pc2U8Qml0d2lnUmVzcG9uc2U+IHtcclxuICAgIGlmIChhY3Rpb24uY29vcmRpbmF0ZXMgJiYgYWN0aW9uLnZhbHVlKSB7XHJcbiAgICAgIGNvbnN0IHN1Y2Nlc3MgPSBhd2FpdCB0aGlzLnN5c3RlbUludGVncmF0aW9uLmRyYWdJbkJpdHdpZyhcclxuICAgICAgICBhY3Rpb24uY29vcmRpbmF0ZXMueCwgXHJcbiAgICAgICAgYWN0aW9uLmNvb3JkaW5hdGVzLnksIFxyXG4gICAgICAgIGFjdGlvbi52YWx1ZS54LCBcclxuICAgICAgICBhY3Rpb24udmFsdWUueVxyXG4gICAgICApXHJcbiAgICAgIFxyXG4gICAgICBpZiAoc3VjY2Vzcykge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxyXG4gICAgICAgICAgbWVzc2FnZTogYERyYWdnZWQgZnJvbSAoJHthY3Rpb24uY29vcmRpbmF0ZXMueH0sICR7YWN0aW9uLmNvb3JkaW5hdGVzLnl9KSB0byAoJHthY3Rpb24udmFsdWUueH0sICR7YWN0aW9uLnZhbHVlLnl9KWBcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxyXG4gICAgICAgICAgbWVzc2FnZTogYEZhaWxlZCB0byBkcmFnIGZyb20gKCR7YWN0aW9uLmNvb3JkaW5hdGVzLnh9LCAke2FjdGlvbi5jb29yZGluYXRlcy55fSkgdG8gKCR7YWN0aW9uLnZhbHVlLnh9LCAke2FjdGlvbi52YWx1ZS55fSlgXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxyXG4gICAgICBtZXNzYWdlOiAnSW52YWxpZCBkcmFnIHBhcmFtZXRlcnMnXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFzeW5jIHBlcmZvcm1LZXlib2FyZEFjdGlvbihhY3Rpb246IEJpdHdpZ0FjdGlvbik6IFByb21pc2U8Qml0d2lnUmVzcG9uc2U+IHtcclxuICAgIGNvbnN0IHN1Y2Nlc3MgPSBhd2FpdCB0aGlzLnN5c3RlbUludGVncmF0aW9uLnNlbmRLZXlib2FyZFNob3J0Y3V0KGFjdGlvbi50YXJnZXQpXHJcbiAgICBcclxuICAgIGlmIChzdWNjZXNzKSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcclxuICAgICAgICBtZXNzYWdlOiBgU2VudCBrZXlib2FyZCBpbnB1dDogJHthY3Rpb24udGFyZ2V0fWBcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcclxuICAgICAgICBtZXNzYWdlOiBgRmFpbGVkIHRvIHNlbmQga2V5Ym9hcmQgaW5wdXQ6ICR7YWN0aW9uLnRhcmdldH1gXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgYXN5bmMgcGVyZm9ybU1lbnVBY3Rpb24oYWN0aW9uOiBCaXR3aWdBY3Rpb24pOiBQcm9taXNlPEJpdHdpZ1Jlc3BvbnNlPiB7XHJcbiAgICAvLyBNZW51IGFjdGlvbnMgYXJlIHR5cGljYWxseSBrZXlib2FyZCBzaG9ydGN1dHMgb3IgY2xpY2tzXHJcbiAgICAvLyBGb3Igbm93LCB3ZSdsbCB0cmVhdCB0aGVtIGFzIGtleWJvYXJkIGFjdGlvbnNcclxuICAgIHJldHVybiBhd2FpdCB0aGlzLnBlcmZvcm1LZXlib2FyZEFjdGlvbihhY3Rpb24pXHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFzeW5jIHBlcmZvcm1QYXJhbWV0ZXJBY3Rpb24oYWN0aW9uOiBCaXR3aWdBY3Rpb24pOiBQcm9taXNlPEJpdHdpZ1Jlc3BvbnNlPiB7XHJcbiAgICAvLyBQYXJhbWV0ZXIgYWN0aW9ucyBtaWdodCBpbnZvbHZlIGNsaWNraW5nIG9uIFVJIGVsZW1lbnRzXHJcbiAgICAvLyBGb3Igbm93LCB3ZSdsbCBzaW11bGF0ZSB0aGVtXHJcbiAgICBjb25zb2xlLmxvZyhgU2V0dGluZyBwYXJhbWV0ZXIgJHthY3Rpb24udGFyZ2V0fSB0byAke2FjdGlvbi52YWx1ZX1gKVxyXG4gICAgXHJcbiAgICAvLyBJbiBhIHJlYWwgaW1wbGVtZW50YXRpb24sIHRoaXMgd291bGQ6XHJcbiAgICAvLyAxLiBGaW5kIHRoZSBwYXJhbWV0ZXIgY29udHJvbCBpbiB0aGUgVUlcclxuICAgIC8vIDIuIENsaWNrIG9uIGl0IG9yIGRyYWcgdG8gc2V0IHRoZSB2YWx1ZVxyXG4gICAgLy8gMy4gVXBkYXRlIHRoZSBwYXJhbWV0ZXJcclxuICAgIFxyXG4gICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMCkpXHJcbiAgICBcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHN1Y2Nlc3M6IHRydWUsXHJcbiAgICAgIG1lc3NhZ2U6IGBTZXQgcGFyYW1ldGVyICR7YWN0aW9uLnRhcmdldH0gdG8gJHthY3Rpb24udmFsdWV9YFxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBhc3luYyBwZXJmb3JtRGV2aWNlQWN0aW9uKGFjdGlvbjogQml0d2lnQWN0aW9uKTogUHJvbWlzZTxCaXR3aWdSZXNwb25zZT4ge1xyXG4gICAgLy8gRGV2aWNlIGFjdGlvbnMgbWlnaHQgaW52b2x2ZTpcclxuICAgIC8vIC0gT3BlbmluZyBkZXZpY2UgYnJvd3NlciAoRjQpXHJcbiAgICAvLyAtIENsaWNraW5nIHRvIGFkZCBkZXZpY2VzXHJcbiAgICAvLyAtIERyYWdnaW5nIGRldmljZXMgdG8gdHJhY2tzXHJcbiAgICBcclxuICAgIHN3aXRjaCAoYWN0aW9uLnRhcmdldCkge1xyXG4gICAgICBjYXNlICdhZGRfZXFfZGV2aWNlJzpcclxuICAgICAgICAvLyBPcGVuIGRldmljZSBicm93c2VyIGFuZCBhZGQgRVFcclxuICAgICAgICBjb25zdCBicm93c2VyU3VjY2VzcyA9IGF3YWl0IHRoaXMuc3lzdGVtSW50ZWdyYXRpb24ub3BlbkRldmljZUJyb3dzZXIoKVxyXG4gICAgICAgIGlmICghYnJvd3NlclN1Y2Nlc3MpIHtcclxuICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxyXG4gICAgICAgICAgICBtZXNzYWdlOiAnRmFpbGVkIHRvIG9wZW4gZGV2aWNlIGJyb3dzZXInXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFdhaXQgZm9yIGJyb3dzZXIgdG8gb3BlbiwgdGhlbiBjbGljayBFUSBkZXZpY2VcclxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTAwKSlcclxuICAgICAgICBcclxuICAgICAgICAvLyBUaGlzIHdvdWxkIGNsaWNrIG9uIHRoZSBFUSBkZXZpY2UgaW4gdGhlIGJyb3dzZXJcclxuICAgICAgICAvLyBGb3Igbm93LCB3ZSdsbCBzaW11bGF0ZSBzdWNjZXNzXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXHJcbiAgICAgICAgICBtZXNzYWdlOiAnRVErIGRldmljZSBhZGRlZCB0byB0cmFjaydcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgIGNhc2UgJ2FkZF9zZWxlY3RlZF9kZXZpY2UnOlxyXG4gICAgICAgIC8vIFRoaXMgd291bGQgZHJhZyB0aGUgc2VsZWN0ZWQgZGV2aWNlIHRvIHRoZSB0cmFja1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxyXG4gICAgICAgICAgbWVzc2FnZTogJ1NlbGVjdGVkIGRldmljZSBhZGRlZCB0byB0cmFjaydcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXHJcbiAgICAgICAgICBtZXNzYWdlOiBgRGV2aWNlIGFjdGlvbiBjb21wbGV0ZWQ6ICR7YWN0aW9uLnRhcmdldH1gXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBhc3luYyBwZXJmb3JtVHJhY2tBY3Rpb24oYWN0aW9uOiBCaXR3aWdBY3Rpb24pOiBQcm9taXNlPEJpdHdpZ1Jlc3BvbnNlPiB7XHJcbiAgICAvLyBUcmFjayBhY3Rpb25zIG1pZ2h0IGludm9sdmU6XHJcbiAgICAvLyAtIFJpZ2h0LWNsaWNraW5nIHRvIGFkZCB0cmFja3NcclxuICAgIC8vIC0gQ2xpY2tpbmcgdHJhY2sgY29udHJvbHNcclxuICAgIC8vIC0gTWFuYWdpbmcgdHJhY2sgc2V0dGluZ3NcclxuICAgIFxyXG4gICAgc3dpdGNoIChhY3Rpb24udGFyZ2V0KSB7XHJcbiAgICAgIGNhc2UgJ2FkZF9taWRpX3RyYWNrJzpcclxuICAgICAgICAvLyBUaGlzIHdvdWxkIHJpZ2h0LWNsaWNrIGluIHRyYWNrIGxpc3QgYW5kIHNlbGVjdCBcIkFkZCBNSURJIFRyYWNrXCJcclxuICAgICAgICAvLyBGb3Igbm93LCB3ZSdsbCBzaW11bGF0ZSB0aGUgYWN0aW9uXHJcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMCkpXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXHJcbiAgICAgICAgICBtZXNzYWdlOiAnTUlESSB0cmFjayBhZGRlZCBzdWNjZXNzZnVsbHknXHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxyXG4gICAgICAgICAgbWVzc2FnZTogYFRyYWNrIGFjdGlvbiBjb21wbGV0ZWQ6ICR7YWN0aW9uLnRhcmdldH1gXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gSGlnaC1sZXZlbCBhY3Rpb24gbWV0aG9kc1xyXG4gIGFzeW5jIGNyZWF0ZU5ld1Byb2plY3QoKTogUHJvbWlzZTxCaXR3aWdSZXNwb25zZT4ge1xyXG4gICAgY29uc3Qgc3VjY2VzcyA9IGF3YWl0IHRoaXMuc3lzdGVtSW50ZWdyYXRpb24uY3JlYXRlTmV3UHJvamVjdCgpXHJcbiAgICBcclxuICAgIGlmIChzdWNjZXNzKSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcclxuICAgICAgICBtZXNzYWdlOiAnTmV3IHByb2plY3QgY3JlYXRlZCBzdWNjZXNzZnVsbHknXHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXHJcbiAgICAgICAgbWVzc2FnZTogJ0ZhaWxlZCB0byBjcmVhdGUgbmV3IHByb2plY3QnXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGFzeW5jIHJlY29yZEF1ZGlvKCk6IFByb21pc2U8Qml0d2lnUmVzcG9uc2U+IHtcclxuICAgIGNvbnN0IGFjdGlvbnMgPSBbXHJcbiAgICAgIHtcclxuICAgICAgICB0eXBlOiAnY2xpY2snIGFzIGNvbnN0LFxyXG4gICAgICAgIHRhcmdldDogJ3JlY29yZF9hcm1fYnV0dG9uJyxcclxuICAgICAgICBjb29yZGluYXRlczogeyB4OiAxNTAsIHk6IDEwMCB9LFxyXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnQXJtIHRyYWNrIGZvciByZWNvcmRpbmcnXHJcbiAgICAgIH0sXHJcbiAgICAgIHtcclxuICAgICAgICB0eXBlOiAnY2xpY2snIGFzIGNvbnN0LFxyXG4gICAgICAgIHRhcmdldDogJ21haW5fcmVjb3JkX2J1dHRvbicsXHJcbiAgICAgICAgY29vcmRpbmF0ZXM6IHsgeDogNDAwLCB5OiA1MCB9LFxyXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnU3RhcnQgcmVjb3JkaW5nJ1xyXG4gICAgICB9XHJcbiAgICBdXHJcblxyXG4gICAgZm9yIChjb25zdCBhY3Rpb24gb2YgYWN0aW9ucykge1xyXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmV4ZWN1dGVBY3Rpb24oYWN0aW9uKVxyXG4gICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSByZXR1cm4gcmVzdWx0XHJcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAyMDApKVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIHN1Y2Nlc3M6IHRydWUsXHJcbiAgICAgIG1lc3NhZ2U6ICdBdWRpbyByZWNvcmRpbmcgc3RhcnRlZCdcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGFzeW5jIGFkZEVRRGV2aWNlKCk6IFByb21pc2U8Qml0d2lnUmVzcG9uc2U+IHtcclxuICAgIGNvbnN0IGFjdGlvbjogQml0d2lnQWN0aW9uID0ge1xyXG4gICAgICB0eXBlOiAnZGV2aWNlJyxcclxuICAgICAgdGFyZ2V0OiAnYWRkX2VxX2RldmljZScsXHJcbiAgICAgIGRlc2NyaXB0aW9uOiAnQWRkIEVRKyBkZXZpY2UgdG8gdHJhY2snXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZXhlY3V0ZUFjdGlvbihhY3Rpb24pXHJcbiAgfVxyXG5cclxuICBhc3luYyBzZXRUcmFja1ZvbHVtZSh0cmFja0luZGV4OiBudW1iZXIsIHZvbHVtZTogbnVtYmVyKTogUHJvbWlzZTxCaXR3aWdSZXNwb25zZT4ge1xyXG4gICAgY29uc3QgYWN0aW9uOiBCaXR3aWdBY3Rpb24gPSB7XHJcbiAgICAgIHR5cGU6ICdwYXJhbWV0ZXInLFxyXG4gICAgICB0YXJnZXQ6ICd0cmFja192b2x1bWUnLFxyXG4gICAgICB2YWx1ZTogdm9sdW1lLFxyXG4gICAgICBkZXNjcmlwdGlvbjogYFNldCB0cmFjayAke3RyYWNrSW5kZXh9IHZvbHVtZSB0byAke3ZvbHVtZX1kQmBcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5leGVjdXRlQWN0aW9uKGFjdGlvbilcclxuICB9XHJcblxyXG4gIGFzeW5jIGVuYWJsZUF1dG9tYXRpb24oKTogUHJvbWlzZTxCaXR3aWdSZXNwb25zZT4ge1xyXG4gICAgY29uc3Qgc3VjY2VzcyA9IGF3YWl0IHRoaXMuc3lzdGVtSW50ZWdyYXRpb24udG9nZ2xlQXV0b21hdGlvbigpXHJcbiAgICBcclxuICAgIGlmIChzdWNjZXNzKSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcclxuICAgICAgICBtZXNzYWdlOiAnQXV0b21hdGlvbiBtb2RlIGVuYWJsZWQnXHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXHJcbiAgICAgICAgbWVzc2FnZTogJ0ZhaWxlZCB0byBlbmFibGUgYXV0b21hdGlvbidcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gQWRkaXRpb25hbCBCaXR3aWcgY29udHJvbCBtZXRob2RzXHJcbiAgYXN5bmMgcGxheVN0b3AoKTogUHJvbWlzZTxCaXR3aWdSZXNwb25zZT4ge1xyXG4gICAgY29uc3Qgc3VjY2VzcyA9IGF3YWl0IHRoaXMuc3lzdGVtSW50ZWdyYXRpb24ucGxheVN0b3AoKVxyXG4gICAgXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBzdWNjZXNzLFxyXG4gICAgICBtZXNzYWdlOiBzdWNjZXNzID8gJ1BsYXliYWNrIHRvZ2dsZWQnIDogJ0ZhaWxlZCB0byB0b2dnbGUgcGxheWJhY2snXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhc3luYyB0b2dnbGVNZXRyb25vbWUoKTogUHJvbWlzZTxCaXR3aWdSZXNwb25zZT4ge1xyXG4gICAgY29uc3Qgc3VjY2VzcyA9IGF3YWl0IHRoaXMuc3lzdGVtSW50ZWdyYXRpb24udG9nZ2xlTWV0cm9ub21lKClcclxuICAgIFxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgc3VjY2VzcyxcclxuICAgICAgbWVzc2FnZTogc3VjY2VzcyA/ICdNZXRyb25vbWUgdG9nZ2xlZCcgOiAnRmFpbGVkIHRvIHRvZ2dsZSBtZXRyb25vbWUnXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhc3luYyB1bmRvKCk6IFByb21pc2U8Qml0d2lnUmVzcG9uc2U+IHtcclxuICAgIGNvbnN0IHN1Y2Nlc3MgPSBhd2FpdCB0aGlzLnN5c3RlbUludGVncmF0aW9uLnVuZG8oKVxyXG4gICAgXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBzdWNjZXNzLFxyXG4gICAgICBtZXNzYWdlOiBzdWNjZXNzID8gJ1VuZG8gcGVyZm9ybWVkJyA6ICdGYWlsZWQgdG8gdW5kbydcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGFzeW5jIHJlZG8oKTogUHJvbWlzZTxCaXR3aWdSZXNwb25zZT4ge1xyXG4gICAgY29uc3Qgc3VjY2VzcyA9IGF3YWl0IHRoaXMuc3lzdGVtSW50ZWdyYXRpb24ucmVkbygpXHJcbiAgICBcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHN1Y2Nlc3MsXHJcbiAgICAgIG1lc3NhZ2U6IHN1Y2Nlc3MgPyAnUmVkbyBwZXJmb3JtZWQnIDogJ0ZhaWxlZCB0byByZWRvJ1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgc2F2ZVByb2plY3QoKTogUHJvbWlzZTxCaXR3aWdSZXNwb25zZT4ge1xyXG4gICAgY29uc3Qgc3VjY2VzcyA9IGF3YWl0IHRoaXMuc3lzdGVtSW50ZWdyYXRpb24uc2F2ZVByb2plY3QoKVxyXG4gICAgXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBzdWNjZXNzLFxyXG4gICAgICBtZXNzYWdlOiBzdWNjZXNzID8gJ1Byb2plY3Qgc2F2ZWQnIDogJ0ZhaWxlZCB0byBzYXZlIHByb2plY3QnXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhc3luYyBvcGVuUHJvamVjdCgpOiBQcm9taXNlPEJpdHdpZ1Jlc3BvbnNlPiB7XHJcbiAgICBjb25zdCBzdWNjZXNzID0gYXdhaXQgdGhpcy5zeXN0ZW1JbnRlZ3JhdGlvbi5vcGVuUHJvamVjdCgpXHJcbiAgICBcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHN1Y2Nlc3MsXHJcbiAgICAgIG1lc3NhZ2U6IHN1Y2Nlc3MgPyAnUHJvamVjdCBvcGVuZWQnIDogJ0ZhaWxlZCB0byBvcGVuIHByb2plY3QnXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhc3luYyBleHBvcnRBdWRpbygpOiBQcm9taXNlPEJpdHdpZ1Jlc3BvbnNlPiB7XHJcbiAgICBjb25zdCBzdWNjZXNzID0gYXdhaXQgdGhpcy5zeXN0ZW1JbnRlZ3JhdGlvbi5leHBvcnRBdWRpbygpXHJcbiAgICBcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHN1Y2Nlc3MsXHJcbiAgICAgIG1lc3NhZ2U6IHN1Y2Nlc3MgPyAnQXVkaW8gZXhwb3J0IHN0YXJ0ZWQnIDogJ0ZhaWxlZCB0byBzdGFydCBhdWRpbyBleHBvcnQnXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBnZXRDb25uZWN0aW9uU3RhdHVzKCk6IGJvb2xlYW4ge1xyXG4gICAgcmV0dXJuIHRoaXMuaXNDb25uZWN0ZWQgJiYgdGhpcy5pc0luaXRpYWxpemVkXHJcbiAgfVxyXG5cclxuICBpc0luaXRpYWxpemF0aW9uQ29tcGxldGUoKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gdGhpcy5pc0luaXRpYWxpemVkXHJcbiAgfVxyXG5cclxuICBhc3luYyB3YWl0Rm9ySW5pdGlhbGl6YXRpb24oKTogUHJvbWlzZTxib29sZWFuPiB7XHJcbiAgICB3aGlsZSAoIXRoaXMuaXNJbml0aWFsaXplZCkge1xyXG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwKSlcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLmlzQ29ubmVjdGVkXHJcbiAgfVxyXG5cclxuICBhc3luYyByZWNvbm5lY3QoKTogUHJvbWlzZTxib29sZWFuPiB7XHJcbiAgICB0aGlzLmlzQ29ubmVjdGVkID0gZmFsc2VcclxuICAgIHRoaXMuaXNJbml0aWFsaXplZCA9IGZhbHNlXHJcbiAgICBhd2FpdCB0aGlzLmluaXRpYWxpemVDb25uZWN0aW9uKClcclxuICAgIHJldHVybiB0aGlzLmlzQ29ubmVjdGVkXHJcbiAgfVxyXG5cclxuICBnZXRTeXN0ZW1JbmZvKCk6IHsgcGxhdGZvcm06IHN0cmluZzsgc3VwcG9ydGVkOiBib29sZWFuIH0ge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgcGxhdGZvcm06IHRoaXMuc3lzdGVtSW50ZWdyYXRpb24uZ2V0UGxhdGZvcm0oKSxcclxuICAgICAgc3VwcG9ydGVkOiB0aGlzLnN5c3RlbUludGVncmF0aW9uLmlzU3VwcG9ydGVkKClcclxuICAgIH1cclxuICB9XHJcbn0gIl0sIm5hbWVzIjpbIkJpdHdpZ0NvbnRyb2xsZXIiLCJpbml0aWFsaXplQ29ubmVjdGlvbiIsImNvbnNvbGUiLCJsb2ciLCJpc0Nvbm5lY3RlZCIsImlzSW5pdGlhbGl6ZWQiLCJiYXNlVXJsIiwid2luZG93IiwibG9jYXRpb24iLCJvcmlnaW4iLCJyZXNwb25zZSIsImZldGNoIiwiZGF0YSIsImpzb24iLCJpc1J1bm5pbmciLCJlcnJvciIsImNoZWNrQml0d2lnUnVubmluZyIsImV4ZWN1dGVBY3Rpb24iLCJhY3Rpb24iLCJzdWNjZXNzIiwibWVzc2FnZSIsInR5cGUiLCJwZXJmb3JtQ2xpY2siLCJwZXJmb3JtRHJhZyIsInBlcmZvcm1LZXlib2FyZEFjdGlvbiIsInBlcmZvcm1NZW51QWN0aW9uIiwicGVyZm9ybVBhcmFtZXRlckFjdGlvbiIsInBlcmZvcm1EZXZpY2VBY3Rpb24iLCJwZXJmb3JtVHJhY2tBY3Rpb24iLCJjb29yZGluYXRlcyIsInN5c3RlbUludGVncmF0aW9uIiwiY2xpY2tJbkJpdHdpZyIsIngiLCJ5IiwidGFyZ2V0IiwidmFsdWUiLCJkcmFnSW5CaXR3aWciLCJzZW5kS2V5Ym9hcmRTaG9ydGN1dCIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsImJyb3dzZXJTdWNjZXNzIiwib3BlbkRldmljZUJyb3dzZXIiLCJjcmVhdGVOZXdQcm9qZWN0IiwicmVjb3JkQXVkaW8iLCJhY3Rpb25zIiwiZGVzY3JpcHRpb24iLCJyZXN1bHQiLCJhZGRFUURldmljZSIsInNldFRyYWNrVm9sdW1lIiwidHJhY2tJbmRleCIsInZvbHVtZSIsImVuYWJsZUF1dG9tYXRpb24iLCJ0b2dnbGVBdXRvbWF0aW9uIiwicGxheVN0b3AiLCJ0b2dnbGVNZXRyb25vbWUiLCJ1bmRvIiwicmVkbyIsInNhdmVQcm9qZWN0Iiwib3BlblByb2plY3QiLCJleHBvcnRBdWRpbyIsImdldENvbm5lY3Rpb25TdGF0dXMiLCJpc0luaXRpYWxpemF0aW9uQ29tcGxldGUiLCJ3YWl0Rm9ySW5pdGlhbGl6YXRpb24iLCJyZWNvbm5lY3QiLCJnZXRTeXN0ZW1JbmZvIiwicGxhdGZvcm0iLCJnZXRQbGF0Zm9ybSIsInN1cHBvcnRlZCIsImlzU3VwcG9ydGVkIiwiY29uc3RydWN0b3IiLCJhY3Rpb25RdWV1ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/lib/bitwig-controller.ts\n"));

/***/ })

});