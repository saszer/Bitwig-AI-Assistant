"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./app/lib/bitwig-controller.ts":
/*!**************************************!*\
  !*** ./app/lib/bitwig-controller.ts ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BitwigController: function() { return /* binding */ BitwigController; }\n/* harmony export */ });\nclass BitwigController {\n    async initializeConnection() {\n        try {\n            console.log(\"BitwigController: Initializing connection...\");\n            // Check if we're in browser environment\n            if (false) {}\n            // Use API route to check Bitwig status\n            const baseUrl = window.location.origin;\n            console.log(\"BitwigController: Checking Bitwig via API...\");\n            const response = await fetch(\"\".concat(baseUrl, \"/api/check-bitwig\"));\n            const data = await response.json();\n            this.isConnected = data.isRunning;\n            this.isInitialized = true;\n            if (this.isConnected) {\n                console.log(\"BitwigController: Bitwig Studio detected and ready for control\");\n            } else {\n                console.log(\"BitwigController: Bitwig Studio not detected. Please start Bitwig Studio first.\");\n            }\n        } catch (error) {\n            console.error(\"BitwigController: Failed to initialize Bitwig connection:\", error);\n            this.isConnected = false;\n            this.isInitialized = true;\n        }\n    }\n    async checkBitwigRunning() {\n        // Use API route instead of SystemIntegration\n        if (false) {}\n        try {\n            const baseUrl = window.location.origin;\n            const response = await fetch(\"\".concat(baseUrl, \"/api/check-bitwig\"));\n            const data = await response.json();\n            return data.isRunning;\n        } catch (error) {\n            console.error(\"BitwigController: Failed to check Bitwig status:\", error);\n            return false;\n        }\n    }\n    async executeAction(action) {\n        if (!this.isConnected) {\n            return {\n                success: false,\n                message: \"Bitwig Studio is not running. Please start Bitwig Studio first.\"\n            };\n        }\n        try {\n            switch(action.type){\n                case \"click\":\n                    return await this.performClick(action);\n                case \"drag\":\n                    return await this.performDrag(action);\n                case \"keyboard\":\n                    return await this.performKeyboardAction(action);\n                case \"menu\":\n                    return await this.performMenuAction(action);\n                case \"parameter\":\n                    return await this.performParameterAction(action);\n                case \"device\":\n                    return await this.performDeviceAction(action);\n                case \"track\":\n                    return await this.performTrackAction(action);\n                default:\n                    return {\n                        success: false,\n                        message: \"Unknown action type: \".concat(action.type)\n                    };\n            }\n        } catch (error) {\n            return {\n                success: false,\n                message: \"Failed to execute action: \".concat(error)\n            };\n        }\n    }\n    async performClick(action) {\n        if (action.coordinates) {\n            console.log(\"Simulating click at coordinates (\".concat(action.coordinates.x, \", \").concat(action.coordinates.y, \")\"));\n            // Simulate the action with a delay\n            await new Promise((resolve)=>setTimeout(resolve, 200));\n            return {\n                success: true,\n                message: \"Clicked \".concat(action.target, \" at coordinates (\").concat(action.coordinates.x, \", \").concat(action.coordinates.y, \")\")\n            };\n        }\n        return {\n            success: false,\n            message: \"No coordinates provided for click action\"\n        };\n    }\n    async performDrag(action) {\n        if (action.coordinates && action.value) {\n            console.log(\"Simulating drag from (\".concat(action.coordinates.x, \", \").concat(action.coordinates.y, \") to (\").concat(action.value.x, \", \").concat(action.value.y, \")\"));\n            // Simulate the action with a delay\n            await new Promise((resolve)=>setTimeout(resolve, 300));\n            return {\n                success: true,\n                message: \"Dragged from (\".concat(action.coordinates.x, \", \").concat(action.coordinates.y, \") to (\").concat(action.value.x, \", \").concat(action.value.y, \")\")\n            };\n        }\n        return {\n            success: false,\n            message: \"Invalid drag parameters\"\n        };\n    }\n    async performKeyboardAction(action) {\n        console.log(\"Simulating keyboard input: \".concat(action.target));\n        // Simulate the action with a delay\n        await new Promise((resolve)=>setTimeout(resolve, 100));\n        return {\n            success: true,\n            message: \"Sent keyboard input: \".concat(action.target)\n        };\n    }\n    async performMenuAction(action) {\n        // Menu actions are typically keyboard shortcuts or clicks\n        // For now, we'll treat them as keyboard actions\n        return await this.performKeyboardAction(action);\n    }\n    async performParameterAction(action) {\n        // Parameter actions might involve clicking on UI elements\n        // For now, we'll simulate them\n        console.log(\"Setting parameter \".concat(action.target, \" to \").concat(action.value));\n        // In a real implementation, this would:\n        // 1. Find the parameter control in the UI\n        // 2. Click on it or drag to set the value\n        // 3. Update the parameter\n        await new Promise((resolve)=>setTimeout(resolve, 100));\n        return {\n            success: true,\n            message: \"Set parameter \".concat(action.target, \" to \").concat(action.value)\n        };\n    }\n    async performDeviceAction(action) {\n        // Device actions might involve:\n        // - Opening device browser (F4)\n        // - Clicking to add devices\n        // - Dragging devices to tracks\n        switch(action.target){\n            case \"add_eq_device\":\n                // Open device browser and add EQ\n                const browserSuccess = await this.systemIntegration.openDeviceBrowser();\n                if (!browserSuccess) {\n                    return {\n                        success: false,\n                        message: \"Failed to open device browser\"\n                    };\n                }\n                // Wait for browser to open, then click EQ device\n                await new Promise((resolve)=>setTimeout(resolve, 500));\n                // This would click on the EQ device in the browser\n                // For now, we'll simulate success\n                return {\n                    success: true,\n                    message: \"EQ+ device added to track\"\n                };\n            case \"add_selected_device\":\n                // This would drag the selected device to the track\n                return {\n                    success: true,\n                    message: \"Selected device added to track\"\n                };\n            default:\n                return {\n                    success: true,\n                    message: \"Device action completed: \".concat(action.target)\n                };\n        }\n    }\n    async performTrackAction(action) {\n        // Track actions might involve:\n        // - Right-clicking to add tracks\n        // - Clicking track controls\n        // - Managing track settings\n        switch(action.target){\n            case \"add_midi_track\":\n                // This would right-click in track list and select \"Add MIDI Track\"\n                // For now, we'll simulate the action\n                await new Promise((resolve)=>setTimeout(resolve, 100));\n                return {\n                    success: true,\n                    message: \"MIDI track added successfully\"\n                };\n            default:\n                return {\n                    success: true,\n                    message: \"Track action completed: \".concat(action.target)\n                };\n        }\n    }\n    // High-level action methods\n    async createNewProject() {\n        const success = await this.systemIntegration.createNewProject();\n        if (success) {\n            return {\n                success: true,\n                message: \"New project created successfully\"\n            };\n        } else {\n            return {\n                success: false,\n                message: \"Failed to create new project\"\n            };\n        }\n    }\n    async recordAudio() {\n        const actions = [\n            {\n                type: \"click\",\n                target: \"record_arm_button\",\n                coordinates: {\n                    x: 150,\n                    y: 100\n                },\n                description: \"Arm track for recording\"\n            },\n            {\n                type: \"click\",\n                target: \"main_record_button\",\n                coordinates: {\n                    x: 400,\n                    y: 50\n                },\n                description: \"Start recording\"\n            }\n        ];\n        for (const action of actions){\n            const result = await this.executeAction(action);\n            if (!result.success) return result;\n            await new Promise((resolve)=>setTimeout(resolve, 200));\n        }\n        return {\n            success: true,\n            message: \"Audio recording started\"\n        };\n    }\n    async addEQDevice() {\n        const action = {\n            type: \"device\",\n            target: \"add_eq_device\",\n            description: \"Add EQ+ device to track\"\n        };\n        return await this.executeAction(action);\n    }\n    async setTrackVolume(trackIndex, volume) {\n        const action = {\n            type: \"parameter\",\n            target: \"track_volume\",\n            value: volume,\n            description: \"Set track \".concat(trackIndex, \" volume to \").concat(volume, \"dB\")\n        };\n        return await this.executeAction(action);\n    }\n    async enableAutomation() {\n        const success = await this.systemIntegration.toggleAutomation();\n        if (success) {\n            return {\n                success: true,\n                message: \"Automation mode enabled\"\n            };\n        } else {\n            return {\n                success: false,\n                message: \"Failed to enable automation\"\n            };\n        }\n    }\n    // Additional Bitwig control methods\n    async playStop() {\n        const success = await this.systemIntegration.playStop();\n        return {\n            success,\n            message: success ? \"Playback toggled\" : \"Failed to toggle playback\"\n        };\n    }\n    async toggleMetronome() {\n        const success = await this.systemIntegration.toggleMetronome();\n        return {\n            success,\n            message: success ? \"Metronome toggled\" : \"Failed to toggle metronome\"\n        };\n    }\n    async undo() {\n        const success = await this.systemIntegration.undo();\n        return {\n            success,\n            message: success ? \"Undo performed\" : \"Failed to undo\"\n        };\n    }\n    async redo() {\n        const success = await this.systemIntegration.redo();\n        return {\n            success,\n            message: success ? \"Redo performed\" : \"Failed to redo\"\n        };\n    }\n    async saveProject() {\n        const success = await this.systemIntegration.saveProject();\n        return {\n            success,\n            message: success ? \"Project saved\" : \"Failed to save project\"\n        };\n    }\n    async openProject() {\n        const success = await this.systemIntegration.openProject();\n        return {\n            success,\n            message: success ? \"Project opened\" : \"Failed to open project\"\n        };\n    }\n    async exportAudio() {\n        const success = await this.systemIntegration.exportAudio();\n        return {\n            success,\n            message: success ? \"Audio export started\" : \"Failed to start audio export\"\n        };\n    }\n    getConnectionStatus() {\n        return this.isConnected && this.isInitialized;\n    }\n    isInitializationComplete() {\n        return this.isInitialized;\n    }\n    async waitForInitialization() {\n        while(!this.isInitialized){\n            await new Promise((resolve)=>setTimeout(resolve, 100));\n        }\n        return this.isConnected;\n    }\n    async reconnect() {\n        this.isConnected = false;\n        this.isInitialized = false;\n        await this.initializeConnection();\n        return this.isConnected;\n    }\n    getSystemInfo() {\n        return {\n            platform: this.systemIntegration.getPlatform(),\n            supported: this.systemIntegration.isSupported()\n        };\n    }\n    constructor(){\n        this.isConnected = false;\n        this.isInitialized = false;\n        this.actionQueue = [];\n        // Only initialize connection on client side\n        if (true) {\n            this.initializeConnection();\n        }\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9saWIvYml0d2lnLWNvbnRyb2xsZXIudHMiLCJtYXBwaW5ncyI6Ijs7OztBQWNPLE1BQU1BO0lBWVgsTUFBY0MsdUJBQXVCO1FBQ25DLElBQUk7WUFDRkMsUUFBUUMsR0FBRyxDQUFDO1lBRVosd0NBQXdDO1lBQ3hDLElBQUksS0FBa0IsRUFBYSxFQUtsQztZQUVELHVDQUF1QztZQUN2QyxNQUFNRyxVQUFVQyxPQUFPQyxRQUFRLENBQUNDLE1BQU07WUFDdENQLFFBQVFDLEdBQUcsQ0FBQztZQUNaLE1BQU1PLFdBQVcsTUFBTUMsTUFBTSxHQUFXLE9BQVJMLFNBQVE7WUFDeEMsTUFBTU0sT0FBTyxNQUFNRixTQUFTRyxJQUFJO1lBRWhDLElBQUksQ0FBQ1QsV0FBVyxHQUFHUSxLQUFLRSxTQUFTO1lBQ2pDLElBQUksQ0FBQ1QsYUFBYSxHQUFHO1lBRXJCLElBQUksSUFBSSxDQUFDRCxXQUFXLEVBQUU7Z0JBQ3BCRixRQUFRQyxHQUFHLENBQUM7WUFDZCxPQUFPO2dCQUNMRCxRQUFRQyxHQUFHLENBQUM7WUFDZDtRQUNGLEVBQUUsT0FBT1ksT0FBTztZQUNkYixRQUFRYSxLQUFLLENBQUMsNkRBQTZEQTtZQUMzRSxJQUFJLENBQUNYLFdBQVcsR0FBRztZQUNuQixJQUFJLENBQUNDLGFBQWEsR0FBRztRQUN2QjtJQUNGO0lBRUEsTUFBY1cscUJBQXVDO1FBQ25ELDZDQUE2QztRQUM3QyxJQUFJLEtBQWtCLEVBQWEsRUFFbEM7UUFFRCxJQUFJO1lBQ0YsTUFBTVYsVUFBVUMsT0FBT0MsUUFBUSxDQUFDQyxNQUFNO1lBQ3RDLE1BQU1DLFdBQVcsTUFBTUMsTUFBTSxHQUFXLE9BQVJMLFNBQVE7WUFDeEMsTUFBTU0sT0FBTyxNQUFNRixTQUFTRyxJQUFJO1lBQ2hDLE9BQU9ELEtBQUtFLFNBQVM7UUFDdkIsRUFBRSxPQUFPQyxPQUFPO1lBQ2RiLFFBQVFhLEtBQUssQ0FBQyxvREFBb0RBO1lBQ2xFLE9BQU87UUFDVDtJQUNG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QVdELFNBQVM7UUFDbkQ7UUFDQSxPQUFPLElBQUksQ0FBQzdCLFdBQVc7SUFDekI7SUFFQSxNQUFNeUQsWUFBOEI7UUFDbEMsSUFBSSxDQUFDekQsV0FBVyxHQUFHO1FBQ25CLElBQUksQ0FBQ0MsYUFBYSxHQUFHO1FBQ3JCLE1BQU0sSUFBSSxDQUFDSixvQkFBb0I7UUFDL0IsT0FBTyxJQUFJLENBQUNHLFdBQVc7SUFDekI7SUFFQTBELGdCQUEwRDtRQUN4RCxPQUFPO1lBQ0xDLFVBQVUsSUFBSSxDQUFDekIsaUJBQWlCLENBQUMwQixXQUFXO1lBQzVDQyxXQUFXLElBQUksQ0FBQzNCLGlCQUFpQixDQUFDNEIsV0FBVztRQUMvQztJQUNGO0lBeFpBQyxhQUFjO2FBSk4vRCxjQUF1QjthQUN2QkMsZ0JBQXlCO2FBQ3pCK0QsY0FBOEIsRUFBRTtRQUd0Qyw0Q0FBNEM7UUFDNUMsSUFBSSxJQUFrQixFQUFhO1lBQ2pDLElBQUksQ0FBQ25FLG9CQUFvQjtRQUMzQjtJQUNGO0FBb1pGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2FwcC9saWIvYml0d2lnLWNvbnRyb2xsZXIudHM/MDU2MyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbnRlcmZhY2UgQml0d2lnQWN0aW9uIHtcclxuICB0eXBlOiAnY2xpY2snIHwgJ2RyYWcnIHwgJ2tleWJvYXJkJyB8ICdtZW51JyB8ICdwYXJhbWV0ZXInIHwgJ2RldmljZScgfCAndHJhY2snXHJcbiAgdGFyZ2V0OiBzdHJpbmdcclxuICB2YWx1ZT86IGFueVxyXG4gIGNvb3JkaW5hdGVzPzogeyB4OiBudW1iZXI7IHk6IG51bWJlciB9XHJcbiAgZGVzY3JpcHRpb246IHN0cmluZ1xyXG59XHJcblxyXG5pbnRlcmZhY2UgQml0d2lnUmVzcG9uc2Uge1xyXG4gIHN1Y2Nlc3M6IGJvb2xlYW5cclxuICBtZXNzYWdlOiBzdHJpbmdcclxuICBkYXRhPzogYW55XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBCaXR3aWdDb250cm9sbGVyIHtcclxuICBwcml2YXRlIGlzQ29ubmVjdGVkOiBib29sZWFuID0gZmFsc2VcclxuICBwcml2YXRlIGlzSW5pdGlhbGl6ZWQ6IGJvb2xlYW4gPSBmYWxzZVxyXG4gIHByaXZhdGUgYWN0aW9uUXVldWU6IEJpdHdpZ0FjdGlvbltdID0gW11cclxuXHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAvLyBPbmx5IGluaXRpYWxpemUgY29ubmVjdGlvbiBvbiBjbGllbnQgc2lkZVxyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZUNvbm5lY3Rpb24oKVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBhc3luYyBpbml0aWFsaXplQ29ubmVjdGlvbigpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdCaXR3aWdDb250cm9sbGVyOiBJbml0aWFsaXppbmcgY29ubmVjdGlvbi4uLicpXHJcbiAgICAgIFxyXG4gICAgICAvLyBDaGVjayBpZiB3ZSdyZSBpbiBicm93c2VyIGVudmlyb25tZW50XHJcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdCaXR3aWdDb250cm9sbGVyOiBOb3QgaW4gYnJvd3Nlciwgc2tpcHBpbmcgaW5pdGlhbGl6YXRpb24nKVxyXG4gICAgICAgIHRoaXMuaXNDb25uZWN0ZWQgPSBmYWxzZVxyXG4gICAgICAgIHRoaXMuaXNJbml0aWFsaXplZCA9IHRydWVcclxuICAgICAgICByZXR1cm5cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gVXNlIEFQSSByb3V0ZSB0byBjaGVjayBCaXR3aWcgc3RhdHVzXHJcbiAgICAgIGNvbnN0IGJhc2VVcmwgPSB3aW5kb3cubG9jYXRpb24ub3JpZ2luXHJcbiAgICAgIGNvbnNvbGUubG9nKCdCaXR3aWdDb250cm9sbGVyOiBDaGVja2luZyBCaXR3aWcgdmlhIEFQSS4uLicpXHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7YmFzZVVybH0vYXBpL2NoZWNrLWJpdHdpZ2ApXHJcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKClcclxuICAgICAgXHJcbiAgICAgIHRoaXMuaXNDb25uZWN0ZWQgPSBkYXRhLmlzUnVubmluZ1xyXG4gICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQgPSB0cnVlXHJcbiAgICAgIFxyXG4gICAgICBpZiAodGhpcy5pc0Nvbm5lY3RlZCkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdCaXR3aWdDb250cm9sbGVyOiBCaXR3aWcgU3R1ZGlvIGRldGVjdGVkIGFuZCByZWFkeSBmb3IgY29udHJvbCcpXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ0JpdHdpZ0NvbnRyb2xsZXI6IEJpdHdpZyBTdHVkaW8gbm90IGRldGVjdGVkLiBQbGVhc2Ugc3RhcnQgQml0d2lnIFN0dWRpbyBmaXJzdC4nKVxyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdCaXR3aWdDb250cm9sbGVyOiBGYWlsZWQgdG8gaW5pdGlhbGl6ZSBCaXR3aWcgY29ubmVjdGlvbjonLCBlcnJvcilcclxuICAgICAgdGhpcy5pc0Nvbm5lY3RlZCA9IGZhbHNlXHJcbiAgICAgIHRoaXMuaXNJbml0aWFsaXplZCA9IHRydWVcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgYXN5bmMgY2hlY2tCaXR3aWdSdW5uaW5nKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xyXG4gICAgLy8gVXNlIEFQSSByb3V0ZSBpbnN0ZWFkIG9mIFN5c3RlbUludGVncmF0aW9uXHJcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlXHJcbiAgICB9XHJcbiAgICBcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IGJhc2VVcmwgPSB3aW5kb3cubG9jYXRpb24ub3JpZ2luXHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7YmFzZVVybH0vYXBpL2NoZWNrLWJpdHdpZ2ApXHJcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKClcclxuICAgICAgcmV0dXJuIGRhdGEuaXNSdW5uaW5nXHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdCaXR3aWdDb250cm9sbGVyOiBGYWlsZWQgdG8gY2hlY2sgQml0d2lnIHN0YXR1czonLCBlcnJvcilcclxuICAgICAgcmV0dXJuIGZhbHNlXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhc3luYyBleGVjdXRlQWN0aW9uKGFjdGlvbjogQml0d2lnQWN0aW9uKTogUHJvbWlzZTxCaXR3aWdSZXNwb25zZT4ge1xyXG4gICAgaWYgKCF0aGlzLmlzQ29ubmVjdGVkKSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXHJcbiAgICAgICAgbWVzc2FnZTogJ0JpdHdpZyBTdHVkaW8gaXMgbm90IHJ1bm5pbmcuIFBsZWFzZSBzdGFydCBCaXR3aWcgU3R1ZGlvIGZpcnN0LidcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcclxuICAgICAgICBjYXNlICdjbGljayc6XHJcbiAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wZXJmb3JtQ2xpY2soYWN0aW9uKVxyXG4gICAgICAgIGNhc2UgJ2RyYWcnOlxyXG4gICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucGVyZm9ybURyYWcoYWN0aW9uKVxyXG4gICAgICAgIGNhc2UgJ2tleWJvYXJkJzpcclxuICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnBlcmZvcm1LZXlib2FyZEFjdGlvbihhY3Rpb24pXHJcbiAgICAgICAgY2FzZSAnbWVudSc6XHJcbiAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wZXJmb3JtTWVudUFjdGlvbihhY3Rpb24pXHJcbiAgICAgICAgY2FzZSAncGFyYW1ldGVyJzpcclxuICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnBlcmZvcm1QYXJhbWV0ZXJBY3Rpb24oYWN0aW9uKVxyXG4gICAgICAgIGNhc2UgJ2RldmljZSc6XHJcbiAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wZXJmb3JtRGV2aWNlQWN0aW9uKGFjdGlvbilcclxuICAgICAgICBjYXNlICd0cmFjayc6XHJcbiAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wZXJmb3JtVHJhY2tBY3Rpb24oYWN0aW9uKVxyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcclxuICAgICAgICAgICAgbWVzc2FnZTogYFVua25vd24gYWN0aW9uIHR5cGU6ICR7YWN0aW9uLnR5cGV9YFxyXG4gICAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxyXG4gICAgICAgIG1lc3NhZ2U6IGBGYWlsZWQgdG8gZXhlY3V0ZSBhY3Rpb246ICR7ZXJyb3J9YFxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFzeW5jIHBlcmZvcm1DbGljayhhY3Rpb246IEJpdHdpZ0FjdGlvbik6IFByb21pc2U8Qml0d2lnUmVzcG9uc2U+IHtcclxuICAgIGlmIChhY3Rpb24uY29vcmRpbmF0ZXMpIHtcclxuICAgICAgY29uc29sZS5sb2coYFNpbXVsYXRpbmcgY2xpY2sgYXQgY29vcmRpbmF0ZXMgKCR7YWN0aW9uLmNvb3JkaW5hdGVzLnh9LCAke2FjdGlvbi5jb29yZGluYXRlcy55fSlgKVxyXG4gICAgICBcclxuICAgICAgLy8gU2ltdWxhdGUgdGhlIGFjdGlvbiB3aXRoIGEgZGVsYXlcclxuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDIwMCkpXHJcbiAgICAgIFxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXHJcbiAgICAgICAgbWVzc2FnZTogYENsaWNrZWQgJHthY3Rpb24udGFyZ2V0fSBhdCBjb29yZGluYXRlcyAoJHthY3Rpb24uY29vcmRpbmF0ZXMueH0sICR7YWN0aW9uLmNvb3JkaW5hdGVzLnl9KWBcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBzdWNjZXNzOiBmYWxzZSxcclxuICAgICAgbWVzc2FnZTogJ05vIGNvb3JkaW5hdGVzIHByb3ZpZGVkIGZvciBjbGljayBhY3Rpb24nXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFzeW5jIHBlcmZvcm1EcmFnKGFjdGlvbjogQml0d2lnQWN0aW9uKTogUHJvbWlzZTxCaXR3aWdSZXNwb25zZT4ge1xyXG4gICAgaWYgKGFjdGlvbi5jb29yZGluYXRlcyAmJiBhY3Rpb24udmFsdWUpIHtcclxuICAgICAgY29uc29sZS5sb2coYFNpbXVsYXRpbmcgZHJhZyBmcm9tICgke2FjdGlvbi5jb29yZGluYXRlcy54fSwgJHthY3Rpb24uY29vcmRpbmF0ZXMueX0pIHRvICgke2FjdGlvbi52YWx1ZS54fSwgJHthY3Rpb24udmFsdWUueX0pYClcclxuICAgICAgXHJcbiAgICAgIC8vIFNpbXVsYXRlIHRoZSBhY3Rpb24gd2l0aCBhIGRlbGF5XHJcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAzMDApKVxyXG4gICAgICBcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBzdWNjZXNzOiB0cnVlLFxyXG4gICAgICAgIG1lc3NhZ2U6IGBEcmFnZ2VkIGZyb20gKCR7YWN0aW9uLmNvb3JkaW5hdGVzLnh9LCAke2FjdGlvbi5jb29yZGluYXRlcy55fSkgdG8gKCR7YWN0aW9uLnZhbHVlLnh9LCAke2FjdGlvbi52YWx1ZS55fSlgXHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgc3VjY2VzczogZmFsc2UsXHJcbiAgICAgIG1lc3NhZ2U6ICdJbnZhbGlkIGRyYWcgcGFyYW1ldGVycydcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgYXN5bmMgcGVyZm9ybUtleWJvYXJkQWN0aW9uKGFjdGlvbjogQml0d2lnQWN0aW9uKTogUHJvbWlzZTxCaXR3aWdSZXNwb25zZT4ge1xyXG4gICAgY29uc29sZS5sb2coYFNpbXVsYXRpbmcga2V5Ym9hcmQgaW5wdXQ6ICR7YWN0aW9uLnRhcmdldH1gKVxyXG4gICAgXHJcbiAgICAvLyBTaW11bGF0ZSB0aGUgYWN0aW9uIHdpdGggYSBkZWxheVxyXG4gICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMCkpXHJcbiAgICBcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHN1Y2Nlc3M6IHRydWUsXHJcbiAgICAgIG1lc3NhZ2U6IGBTZW50IGtleWJvYXJkIGlucHV0OiAke2FjdGlvbi50YXJnZXR9YFxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBhc3luYyBwZXJmb3JtTWVudUFjdGlvbihhY3Rpb246IEJpdHdpZ0FjdGlvbik6IFByb21pc2U8Qml0d2lnUmVzcG9uc2U+IHtcclxuICAgIC8vIE1lbnUgYWN0aW9ucyBhcmUgdHlwaWNhbGx5IGtleWJvYXJkIHNob3J0Y3V0cyBvciBjbGlja3NcclxuICAgIC8vIEZvciBub3csIHdlJ2xsIHRyZWF0IHRoZW0gYXMga2V5Ym9hcmQgYWN0aW9uc1xyXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMucGVyZm9ybUtleWJvYXJkQWN0aW9uKGFjdGlvbilcclxuICB9XHJcblxyXG4gIHByaXZhdGUgYXN5bmMgcGVyZm9ybVBhcmFtZXRlckFjdGlvbihhY3Rpb246IEJpdHdpZ0FjdGlvbik6IFByb21pc2U8Qml0d2lnUmVzcG9uc2U+IHtcclxuICAgIC8vIFBhcmFtZXRlciBhY3Rpb25zIG1pZ2h0IGludm9sdmUgY2xpY2tpbmcgb24gVUkgZWxlbWVudHNcclxuICAgIC8vIEZvciBub3csIHdlJ2xsIHNpbXVsYXRlIHRoZW1cclxuICAgIGNvbnNvbGUubG9nKGBTZXR0aW5nIHBhcmFtZXRlciAke2FjdGlvbi50YXJnZXR9IHRvICR7YWN0aW9uLnZhbHVlfWApXHJcbiAgICBcclxuICAgIC8vIEluIGEgcmVhbCBpbXBsZW1lbnRhdGlvbiwgdGhpcyB3b3VsZDpcclxuICAgIC8vIDEuIEZpbmQgdGhlIHBhcmFtZXRlciBjb250cm9sIGluIHRoZSBVSVxyXG4gICAgLy8gMi4gQ2xpY2sgb24gaXQgb3IgZHJhZyB0byBzZXQgdGhlIHZhbHVlXHJcbiAgICAvLyAzLiBVcGRhdGUgdGhlIHBhcmFtZXRlclxyXG4gICAgXHJcbiAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwKSlcclxuICAgIFxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgc3VjY2VzczogdHJ1ZSxcclxuICAgICAgbWVzc2FnZTogYFNldCBwYXJhbWV0ZXIgJHthY3Rpb24udGFyZ2V0fSB0byAke2FjdGlvbi52YWx1ZX1gXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFzeW5jIHBlcmZvcm1EZXZpY2VBY3Rpb24oYWN0aW9uOiBCaXR3aWdBY3Rpb24pOiBQcm9taXNlPEJpdHdpZ1Jlc3BvbnNlPiB7XHJcbiAgICAvLyBEZXZpY2UgYWN0aW9ucyBtaWdodCBpbnZvbHZlOlxyXG4gICAgLy8gLSBPcGVuaW5nIGRldmljZSBicm93c2VyIChGNClcclxuICAgIC8vIC0gQ2xpY2tpbmcgdG8gYWRkIGRldmljZXNcclxuICAgIC8vIC0gRHJhZ2dpbmcgZGV2aWNlcyB0byB0cmFja3NcclxuICAgIFxyXG4gICAgc3dpdGNoIChhY3Rpb24udGFyZ2V0KSB7XHJcbiAgICAgIGNhc2UgJ2FkZF9lcV9kZXZpY2UnOlxyXG4gICAgICAgIC8vIE9wZW4gZGV2aWNlIGJyb3dzZXIgYW5kIGFkZCBFUVxyXG4gICAgICAgIGNvbnN0IGJyb3dzZXJTdWNjZXNzID0gYXdhaXQgdGhpcy5zeXN0ZW1JbnRlZ3JhdGlvbi5vcGVuRGV2aWNlQnJvd3NlcigpXHJcbiAgICAgICAgaWYgKCFicm93c2VyU3VjY2Vzcykge1xyXG4gICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXHJcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdGYWlsZWQgdG8gb3BlbiBkZXZpY2UgYnJvd3NlcidcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gV2FpdCBmb3IgYnJvd3NlciB0byBvcGVuLCB0aGVuIGNsaWNrIEVRIGRldmljZVxyXG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1MDApKVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFRoaXMgd291bGQgY2xpY2sgb24gdGhlIEVRIGRldmljZSBpbiB0aGUgYnJvd3NlclxyXG4gICAgICAgIC8vIEZvciBub3csIHdlJ2xsIHNpbXVsYXRlIHN1Y2Nlc3NcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgc3VjY2VzczogdHJ1ZSxcclxuICAgICAgICAgIG1lc3NhZ2U6ICdFUSsgZGV2aWNlIGFkZGVkIHRvIHRyYWNrJ1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgY2FzZSAnYWRkX3NlbGVjdGVkX2RldmljZSc6XHJcbiAgICAgICAgLy8gVGhpcyB3b3VsZCBkcmFnIHRoZSBzZWxlY3RlZCBkZXZpY2UgdG8gdGhlIHRyYWNrXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXHJcbiAgICAgICAgICBtZXNzYWdlOiAnU2VsZWN0ZWQgZGV2aWNlIGFkZGVkIHRvIHRyYWNrJ1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgc3VjY2VzczogdHJ1ZSxcclxuICAgICAgICAgIG1lc3NhZ2U6IGBEZXZpY2UgYWN0aW9uIGNvbXBsZXRlZDogJHthY3Rpb24udGFyZ2V0fWBcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFzeW5jIHBlcmZvcm1UcmFja0FjdGlvbihhY3Rpb246IEJpdHdpZ0FjdGlvbik6IFByb21pc2U8Qml0d2lnUmVzcG9uc2U+IHtcclxuICAgIC8vIFRyYWNrIGFjdGlvbnMgbWlnaHQgaW52b2x2ZTpcclxuICAgIC8vIC0gUmlnaHQtY2xpY2tpbmcgdG8gYWRkIHRyYWNrc1xyXG4gICAgLy8gLSBDbGlja2luZyB0cmFjayBjb250cm9sc1xyXG4gICAgLy8gLSBNYW5hZ2luZyB0cmFjayBzZXR0aW5nc1xyXG4gICAgXHJcbiAgICBzd2l0Y2ggKGFjdGlvbi50YXJnZXQpIHtcclxuICAgICAgY2FzZSAnYWRkX21pZGlfdHJhY2snOlxyXG4gICAgICAgIC8vIFRoaXMgd291bGQgcmlnaHQtY2xpY2sgaW4gdHJhY2sgbGlzdCBhbmQgc2VsZWN0IFwiQWRkIE1JREkgVHJhY2tcIlxyXG4gICAgICAgIC8vIEZvciBub3csIHdlJ2xsIHNpbXVsYXRlIHRoZSBhY3Rpb25cclxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwKSlcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgc3VjY2VzczogdHJ1ZSxcclxuICAgICAgICAgIG1lc3NhZ2U6ICdNSURJIHRyYWNrIGFkZGVkIHN1Y2Nlc3NmdWxseSdcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXHJcbiAgICAgICAgICBtZXNzYWdlOiBgVHJhY2sgYWN0aW9uIGNvbXBsZXRlZDogJHthY3Rpb24udGFyZ2V0fWBcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBIaWdoLWxldmVsIGFjdGlvbiBtZXRob2RzXHJcbiAgYXN5bmMgY3JlYXRlTmV3UHJvamVjdCgpOiBQcm9taXNlPEJpdHdpZ1Jlc3BvbnNlPiB7XHJcbiAgICBjb25zdCBzdWNjZXNzID0gYXdhaXQgdGhpcy5zeXN0ZW1JbnRlZ3JhdGlvbi5jcmVhdGVOZXdQcm9qZWN0KClcclxuICAgIFxyXG4gICAgaWYgKHN1Y2Nlc3MpIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBzdWNjZXNzOiB0cnVlLFxyXG4gICAgICAgIG1lc3NhZ2U6ICdOZXcgcHJvamVjdCBjcmVhdGVkIHN1Y2Nlc3NmdWxseSdcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcclxuICAgICAgICBtZXNzYWdlOiAnRmFpbGVkIHRvIGNyZWF0ZSBuZXcgcHJvamVjdCdcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgcmVjb3JkQXVkaW8oKTogUHJvbWlzZTxCaXR3aWdSZXNwb25zZT4ge1xyXG4gICAgY29uc3QgYWN0aW9ucyA9IFtcclxuICAgICAge1xyXG4gICAgICAgIHR5cGU6ICdjbGljaycgYXMgY29uc3QsXHJcbiAgICAgICAgdGFyZ2V0OiAncmVjb3JkX2FybV9idXR0b24nLFxyXG4gICAgICAgIGNvb3JkaW5hdGVzOiB7IHg6IDE1MCwgeTogMTAwIH0sXHJcbiAgICAgICAgZGVzY3JpcHRpb246ICdBcm0gdHJhY2sgZm9yIHJlY29yZGluZydcclxuICAgICAgfSxcclxuICAgICAge1xyXG4gICAgICAgIHR5cGU6ICdjbGljaycgYXMgY29uc3QsXHJcbiAgICAgICAgdGFyZ2V0OiAnbWFpbl9yZWNvcmRfYnV0dG9uJyxcclxuICAgICAgICBjb29yZGluYXRlczogeyB4OiA0MDAsIHk6IDUwIH0sXHJcbiAgICAgICAgZGVzY3JpcHRpb246ICdTdGFydCByZWNvcmRpbmcnXHJcbiAgICAgIH1cclxuICAgIF1cclxuXHJcbiAgICBmb3IgKGNvbnN0IGFjdGlvbiBvZiBhY3Rpb25zKSB7XHJcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuZXhlY3V0ZUFjdGlvbihhY3Rpb24pXHJcbiAgICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHJldHVybiByZXN1bHRcclxuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDIwMCkpXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgc3VjY2VzczogdHJ1ZSxcclxuICAgICAgbWVzc2FnZTogJ0F1ZGlvIHJlY29yZGluZyBzdGFydGVkJ1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgYWRkRVFEZXZpY2UoKTogUHJvbWlzZTxCaXR3aWdSZXNwb25zZT4ge1xyXG4gICAgY29uc3QgYWN0aW9uOiBCaXR3aWdBY3Rpb24gPSB7XHJcbiAgICAgIHR5cGU6ICdkZXZpY2UnLFxyXG4gICAgICB0YXJnZXQ6ICdhZGRfZXFfZGV2aWNlJyxcclxuICAgICAgZGVzY3JpcHRpb246ICdBZGQgRVErIGRldmljZSB0byB0cmFjaydcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5leGVjdXRlQWN0aW9uKGFjdGlvbilcclxuICB9XHJcblxyXG4gIGFzeW5jIHNldFRyYWNrVm9sdW1lKHRyYWNrSW5kZXg6IG51bWJlciwgdm9sdW1lOiBudW1iZXIpOiBQcm9taXNlPEJpdHdpZ1Jlc3BvbnNlPiB7XHJcbiAgICBjb25zdCBhY3Rpb246IEJpdHdpZ0FjdGlvbiA9IHtcclxuICAgICAgdHlwZTogJ3BhcmFtZXRlcicsXHJcbiAgICAgIHRhcmdldDogJ3RyYWNrX3ZvbHVtZScsXHJcbiAgICAgIHZhbHVlOiB2b2x1bWUsXHJcbiAgICAgIGRlc2NyaXB0aW9uOiBgU2V0IHRyYWNrICR7dHJhY2tJbmRleH0gdm9sdW1lIHRvICR7dm9sdW1lfWRCYFxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBhd2FpdCB0aGlzLmV4ZWN1dGVBY3Rpb24oYWN0aW9uKVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgZW5hYmxlQXV0b21hdGlvbigpOiBQcm9taXNlPEJpdHdpZ1Jlc3BvbnNlPiB7XHJcbiAgICBjb25zdCBzdWNjZXNzID0gYXdhaXQgdGhpcy5zeXN0ZW1JbnRlZ3JhdGlvbi50b2dnbGVBdXRvbWF0aW9uKClcclxuICAgIFxyXG4gICAgaWYgKHN1Y2Nlc3MpIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBzdWNjZXNzOiB0cnVlLFxyXG4gICAgICAgIG1lc3NhZ2U6ICdBdXRvbWF0aW9uIG1vZGUgZW5hYmxlZCdcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcclxuICAgICAgICBtZXNzYWdlOiAnRmFpbGVkIHRvIGVuYWJsZSBhdXRvbWF0aW9uJ1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBBZGRpdGlvbmFsIEJpdHdpZyBjb250cm9sIG1ldGhvZHNcclxuICBhc3luYyBwbGF5U3RvcCgpOiBQcm9taXNlPEJpdHdpZ1Jlc3BvbnNlPiB7XHJcbiAgICBjb25zdCBzdWNjZXNzID0gYXdhaXQgdGhpcy5zeXN0ZW1JbnRlZ3JhdGlvbi5wbGF5U3RvcCgpXHJcbiAgICBcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHN1Y2Nlc3MsXHJcbiAgICAgIG1lc3NhZ2U6IHN1Y2Nlc3MgPyAnUGxheWJhY2sgdG9nZ2xlZCcgOiAnRmFpbGVkIHRvIHRvZ2dsZSBwbGF5YmFjaydcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGFzeW5jIHRvZ2dsZU1ldHJvbm9tZSgpOiBQcm9taXNlPEJpdHdpZ1Jlc3BvbnNlPiB7XHJcbiAgICBjb25zdCBzdWNjZXNzID0gYXdhaXQgdGhpcy5zeXN0ZW1JbnRlZ3JhdGlvbi50b2dnbGVNZXRyb25vbWUoKVxyXG4gICAgXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBzdWNjZXNzLFxyXG4gICAgICBtZXNzYWdlOiBzdWNjZXNzID8gJ01ldHJvbm9tZSB0b2dnbGVkJyA6ICdGYWlsZWQgdG8gdG9nZ2xlIG1ldHJvbm9tZSdcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGFzeW5jIHVuZG8oKTogUHJvbWlzZTxCaXR3aWdSZXNwb25zZT4ge1xyXG4gICAgY29uc3Qgc3VjY2VzcyA9IGF3YWl0IHRoaXMuc3lzdGVtSW50ZWdyYXRpb24udW5kbygpXHJcbiAgICBcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHN1Y2Nlc3MsXHJcbiAgICAgIG1lc3NhZ2U6IHN1Y2Nlc3MgPyAnVW5kbyBwZXJmb3JtZWQnIDogJ0ZhaWxlZCB0byB1bmRvJ1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgcmVkbygpOiBQcm9taXNlPEJpdHdpZ1Jlc3BvbnNlPiB7XHJcbiAgICBjb25zdCBzdWNjZXNzID0gYXdhaXQgdGhpcy5zeXN0ZW1JbnRlZ3JhdGlvbi5yZWRvKClcclxuICAgIFxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgc3VjY2VzcyxcclxuICAgICAgbWVzc2FnZTogc3VjY2VzcyA/ICdSZWRvIHBlcmZvcm1lZCcgOiAnRmFpbGVkIHRvIHJlZG8nXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhc3luYyBzYXZlUHJvamVjdCgpOiBQcm9taXNlPEJpdHdpZ1Jlc3BvbnNlPiB7XHJcbiAgICBjb25zdCBzdWNjZXNzID0gYXdhaXQgdGhpcy5zeXN0ZW1JbnRlZ3JhdGlvbi5zYXZlUHJvamVjdCgpXHJcbiAgICBcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHN1Y2Nlc3MsXHJcbiAgICAgIG1lc3NhZ2U6IHN1Y2Nlc3MgPyAnUHJvamVjdCBzYXZlZCcgOiAnRmFpbGVkIHRvIHNhdmUgcHJvamVjdCdcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGFzeW5jIG9wZW5Qcm9qZWN0KCk6IFByb21pc2U8Qml0d2lnUmVzcG9uc2U+IHtcclxuICAgIGNvbnN0IHN1Y2Nlc3MgPSBhd2FpdCB0aGlzLnN5c3RlbUludGVncmF0aW9uLm9wZW5Qcm9qZWN0KClcclxuICAgIFxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgc3VjY2VzcyxcclxuICAgICAgbWVzc2FnZTogc3VjY2VzcyA/ICdQcm9qZWN0IG9wZW5lZCcgOiAnRmFpbGVkIHRvIG9wZW4gcHJvamVjdCdcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGFzeW5jIGV4cG9ydEF1ZGlvKCk6IFByb21pc2U8Qml0d2lnUmVzcG9uc2U+IHtcclxuICAgIGNvbnN0IHN1Y2Nlc3MgPSBhd2FpdCB0aGlzLnN5c3RlbUludGVncmF0aW9uLmV4cG9ydEF1ZGlvKClcclxuICAgIFxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgc3VjY2VzcyxcclxuICAgICAgbWVzc2FnZTogc3VjY2VzcyA/ICdBdWRpbyBleHBvcnQgc3RhcnRlZCcgOiAnRmFpbGVkIHRvIHN0YXJ0IGF1ZGlvIGV4cG9ydCdcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGdldENvbm5lY3Rpb25TdGF0dXMoKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gdGhpcy5pc0Nvbm5lY3RlZCAmJiB0aGlzLmlzSW5pdGlhbGl6ZWRcclxuICB9XHJcblxyXG4gIGlzSW5pdGlhbGl6YXRpb25Db21wbGV0ZSgpOiBib29sZWFuIHtcclxuICAgIHJldHVybiB0aGlzLmlzSW5pdGlhbGl6ZWRcclxuICB9XHJcblxyXG4gIGFzeW5jIHdhaXRGb3JJbml0aWFsaXphdGlvbigpOiBQcm9taXNlPGJvb2xlYW4+IHtcclxuICAgIHdoaWxlICghdGhpcy5pc0luaXRpYWxpemVkKSB7XHJcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDApKVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMuaXNDb25uZWN0ZWRcclxuICB9XHJcblxyXG4gIGFzeW5jIHJlY29ubmVjdCgpOiBQcm9taXNlPGJvb2xlYW4+IHtcclxuICAgIHRoaXMuaXNDb25uZWN0ZWQgPSBmYWxzZVxyXG4gICAgdGhpcy5pc0luaXRpYWxpemVkID0gZmFsc2VcclxuICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZUNvbm5lY3Rpb24oKVxyXG4gICAgcmV0dXJuIHRoaXMuaXNDb25uZWN0ZWRcclxuICB9XHJcblxyXG4gIGdldFN5c3RlbUluZm8oKTogeyBwbGF0Zm9ybTogc3RyaW5nOyBzdXBwb3J0ZWQ6IGJvb2xlYW4gfSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBwbGF0Zm9ybTogdGhpcy5zeXN0ZW1JbnRlZ3JhdGlvbi5nZXRQbGF0Zm9ybSgpLFxyXG4gICAgICBzdXBwb3J0ZWQ6IHRoaXMuc3lzdGVtSW50ZWdyYXRpb24uaXNTdXBwb3J0ZWQoKVxyXG4gICAgfVxyXG4gIH1cclxufSAiXSwibmFtZXMiOlsiQml0d2lnQ29udHJvbGxlciIsImluaXRpYWxpemVDb25uZWN0aW9uIiwiY29uc29sZSIsImxvZyIsImlzQ29ubmVjdGVkIiwiaXNJbml0aWFsaXplZCIsImJhc2VVcmwiLCJ3aW5kb3ciLCJsb2NhdGlvbiIsIm9yaWdpbiIsInJlc3BvbnNlIiwiZmV0Y2giLCJkYXRhIiwianNvbiIsImlzUnVubmluZyIsImVycm9yIiwiY2hlY2tCaXR3aWdSdW5uaW5nIiwiZXhlY3V0ZUFjdGlvbiIsImFjdGlvbiIsInN1Y2Nlc3MiLCJtZXNzYWdlIiwidHlwZSIsInBlcmZvcm1DbGljayIsInBlcmZvcm1EcmFnIiwicGVyZm9ybUtleWJvYXJkQWN0aW9uIiwicGVyZm9ybU1lbnVBY3Rpb24iLCJwZXJmb3JtUGFyYW1ldGVyQWN0aW9uIiwicGVyZm9ybURldmljZUFjdGlvbiIsInBlcmZvcm1UcmFja0FjdGlvbiIsImNvb3JkaW5hdGVzIiwieCIsInkiLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJ0YXJnZXQiLCJ2YWx1ZSIsImJyb3dzZXJTdWNjZXNzIiwic3lzdGVtSW50ZWdyYXRpb24iLCJvcGVuRGV2aWNlQnJvd3NlciIsImNyZWF0ZU5ld1Byb2plY3QiLCJyZWNvcmRBdWRpbyIsImFjdGlvbnMiLCJkZXNjcmlwdGlvbiIsInJlc3VsdCIsImFkZEVRRGV2aWNlIiwic2V0VHJhY2tWb2x1bWUiLCJ0cmFja0luZGV4Iiwidm9sdW1lIiwiZW5hYmxlQXV0b21hdGlvbiIsInRvZ2dsZUF1dG9tYXRpb24iLCJwbGF5U3RvcCIsInRvZ2dsZU1ldHJvbm9tZSIsInVuZG8iLCJyZWRvIiwic2F2ZVByb2plY3QiLCJvcGVuUHJvamVjdCIsImV4cG9ydEF1ZGlvIiwiZ2V0Q29ubmVjdGlvblN0YXR1cyIsImlzSW5pdGlhbGl6YXRpb25Db21wbGV0ZSIsIndhaXRGb3JJbml0aWFsaXphdGlvbiIsInJlY29ubmVjdCIsImdldFN5c3RlbUluZm8iLCJwbGF0Zm9ybSIsImdldFBsYXRmb3JtIiwic3VwcG9ydGVkIiwiaXNTdXBwb3J0ZWQiLCJjb25zdHJ1Y3RvciIsImFjdGlvblF1ZXVlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/lib/bitwig-controller.ts\n"));

/***/ })

});